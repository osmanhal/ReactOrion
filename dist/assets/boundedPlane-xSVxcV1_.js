import{fA as S,fB as u,fv as h,fy as I,fE as _,J as rn,fx as l,fw as p,fs as P,fV as an,fW as cn,fu as un,eC as z,by as V,ex as gn,fX as bn,eD as m,fY as fn,fZ as E,eq as D,fC as G,ep as v,eA as X}from"./index-BfC8i6jT.js";import{s as B,x as ln}from"./sphere-BgvJtIjV.js";import{v as pn,A as R,j as dn}from"./lineSegment-DbTVMGoh.js";import{E as x,U as Y,v as mn,A as hn,c as r,T as In,S as $n,z as Pn,B as vn,D as Z,J as Nn,a as N,F as A,O as An}from"./plane-ByuX_NXR.js";const O=()=>rn.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class wn{constructor(){this.plane=x(),this.origin=v(),this.basis1=v(),this.basis2=v()}}const xn=wn;function $(n=on){return{plane:x(n.plane),origin:S(n.origin),basis1:S(n.basis1),basis2:S(n.basis2)}}function Mn(n,i,s){const e=Un.get();return e.origin=n,e.basis1=i,e.basis2=s,e.plane=mn(0,0,0,0),T(e),e}function M(n,i=$()){return k(n.origin,n.basis1,n.basis2,i)}function Tn(n,i){u(i.origin,n.origin),u(i.basis1,n.basis1),u(i.basis2,n.basis2),hn(i.plane,n.plane)}function k(n,i,s,e=$()){return u(e.origin,n),u(e.basis1,i),u(e.basis2,s),T(e),Fn(e,"fromValues()"),e}function T(n){Y(n.basis2,n.basis1,n.origin,n.plane)}function L(n,i,s){n!==s&&M(n,s);const e=l(r.get(),f(n),i);return p(s.origin,s.origin,e),s.plane[3]-=i,s}function yn(n,i,s){return H(i,s),L(s,J(n,n.origin),s),s}function H(n,i=$()){const s=(n[2]-n[0])/2,e=(n[3]-n[1])/2;return P(i.origin,n[0]+s,n[1]+e,0),P(i.basis1,s,0,0),P(i.basis2,0,e,0),In(0,0,1,0,i.plane),i}function C(n,i,s){return!!$n(n.plane,i,s)&&en(n,s)}function Sn(n,i,s){if(C(n,i,s))return s;const e=K(n,i,r.get());return p(s,i.origin,l(r.get(),i.direction,an(i.origin,e)/I(i.direction))),s}function K(n,i,s){const e=w.get();tn(n,i,e,w.get());let t=Number.POSITIVE_INFINITY;for(const o of q){const a=U(n,o,y.get()),g=r.get();if(Pn(e,a,g)){const c=cn(r.get(),i.origin,g),b=Math.abs(un(h(i.direction,c)));b<t&&(t=b,u(s,g))}}return t===Number.POSITIVE_INFINITY?Q(n,i,s):s}function Q(n,i,s){if(C(n,i,s))return s;const e=w.get(),t=w.get();tn(n,i,e,t);let o=Number.POSITIVE_INFINITY;for(const a of q){const g=U(n,a,y.get()),c=r.get();if(vn(e,g,c)){const b=ln(i,c);if(!Z(t,c))continue;b<o&&(o=b,u(s,c))}}return F(n,i.origin)<o&&nn(n,i.origin,s),s}function nn(n,i,s){const e=Nn(n.plane,i,r.get()),t=R(W(n,n.basis1),e,-1,1,r.get()),o=R(W(n,n.basis2),e,-1,1,r.get());return z(s,p(r.get(),t,o),n.origin),s}function sn(n,i,s){const{origin:e,basis1:t,basis2:o}=n,a=z(r.get(),i,e),g=N(t,a),c=N(o,a),b=N(f(n),a);return P(s,g,c,b)}function F(n,i){const s=sn(n,i,r.get()),{basis1:e,basis2:t}=n,o=I(e),a=I(t),g=Math.max(Math.abs(s[0])-o,0),c=Math.max(Math.abs(s[1])-a,0),b=s[2];return g*g+c*c+b*b}function _n(n,i){return Math.sqrt(F(n,i))}function Vn(n,i){let s=Number.NEGATIVE_INFINITY;for(const e of q){const t=U(n,e,y.get()),o=dn(t,i);o>s&&(s=o)}return Math.sqrt(s)}function En(n,i){return Z(n.plane,i)&&en(n,i)}function On(n,i,s,e){return Cn(n,s,e)}function J(n,i){const s=-n.plane[3];return N(f(n),i)-s}function jn(n,i,s,e){const t=J(n,i),o=l(Jn,f(n),s-t);return p(e,i,o),e}function Yn(n,i){return V(n.basis1,i.basis1)&&V(n.basis2,i.basis2)&&V(n.origin,i.origin)}function zn(n,i,s){return n!==s&&M(n,s),gn(d,i),bn(d,d),m(s.basis1,n.basis1,d),m(s.basis2,n.basis2,d),m(A(s.plane),A(n.plane),d),m(s.origin,n.origin,i),An(s.plane,s.plane,s.origin),s}function Bn(n,i,s,e){return n!==e&&M(n,e),fn(j,i,s),m(e.basis1,n.basis1,j),m(e.basis2,n.basis2,j),T(e),e}function f(n){return A(n.plane)}function Cn(n,i,s){switch(i){case E.X:u(s,n.basis1),D(s,s);break;case E.Y:u(s,n.basis2),D(s,s);break;case E.Z:u(s,f(n))}return s}function en(n,i){const s=z(r.get(),i,n.origin),e=G(n.basis1),t=G(n.basis2),o=h(n.basis1,s),a=h(n.basis2,s);return-o-e<0&&o-e<0&&-a-t<0&&a-t<0}function W(n,i){const s=y.get();return u(s.origin,n.origin),u(s.vector,i),s}function U(n,i,s){const{basis1:e,basis2:t,origin:o}=n,a=l(r.get(),e,i.origin[0]),g=l(r.get(),t,i.origin[1]);p(s.origin,a,g),p(s.origin,s.origin,o);const c=l(r.get(),e,i.direction[0]),b=l(r.get(),t,i.direction[1]);return l(s.vector,p(c,c,b),2),s}function Fn(n,i){Math.abs(h(n.basis1,n.basis2)/(I(n.basis1)*I(n.basis2)))>1e-6&&O().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(h(n.basis1,f(n)))>1e-6&&O().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-h(f(n),n.origin)-n.plane[3])>1e-6&&O().warn(i,"Plane offset is not consistent with plane origin")}function tn(n,i,s,e){const t=f(n);Y(t,i.direction,i.origin,s),Y(A(s),t,i.origin,e)}const on={plane:x(),origin:_(0,0,0),basis1:_(1,0,0),basis2:_(0,1,0)},w=new B(x),y=new B(pn),Jn=v(),Un=new B(()=>$()),q=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=X(),j=X(),Wn=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:xn,altitudeAt:J,axisAt:On,closestPoint:Q,closestPointOnSilhouette:K,copy:M,copyWithoutVerify:Tn,create:$,distance:_n,distance2:F,distanceToSilhouette:Vn,elevate:L,equals:Yn,extrusionContainsPoint:En,fromAABoundingRect:H,fromValues:k,intersectRay:C,intersectRayClosestSilhouette:Sn,normal:f,projectPoint:nn,projectPointLocal:sn,rotate:Bn,setAltitudeAt:jn,setExtent:yn,transform:zn,up:on,updateUnboundedPlane:T,wrap:Mn},Symbol.toStringTag,{value:"Module"}));export{H as $,xn as G,k as H,T as J,$ as W,M as Z,Wn as _,_n as a,f as d,zn as l,Bn as m,Yn as p,C as s,En as u};
