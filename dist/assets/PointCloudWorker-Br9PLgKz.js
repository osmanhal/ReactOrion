import{fo as v,aZ as $,aR as c,eK as M,fp as d,fq as g,fr as y}from"./index-BfC8i6jT.js";import{t as h,n as I}from"./vec3f32-Cw9Q6TO_.js";import{u as w,c as m,i as S,f as O}from"./PointCloudWorkerUtil-D_haXtwV.js";import{I as x}from"./orientedBoundingBox-Do1Vt1ct.js";import"./PointCloudUniqueValueRenderer-0nzUpUsk.js";import"./I3SBinaryReader-Dg8OkvTP.js";import"./VertexAttribute-BnAa5VW0.js";import"./spatialReferenceEllipsoidUtils-6vOoKuZD.js";import"./computeTranslationToOriginAndRotation-DK7GzGeb.js";import"./plane-ByuX_NXR.js";import"./mathUtils-DIiwy5h7.js";class F{transform(t){const a=this._transform(t),r=[a.points.buffer,a.rgb.buffer];a.pointIdFilterMap!=null&&r.push(a.pointIdFilterMap.buffer);for(const f of a.attributes)"buffer"in f.values&&v(f.values.buffer)&&f.values.buffer!==a.rgb.buffer&&r.push(f.values.buffer);return Promise.resolve({result:a,transferList:r})}_transform(t){const a=w(t.schema,t.geometryBuffer);let r=a.length/3,f=null;const i=new Array,o=m(t.primaryAttributeData,a,r);t.primaryAttributeData!=null&&o&&i.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:o});const u=m(t.modulationAttributeData,a,r);t.modulationAttributeData!=null&&u&&i.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:u});let e=S(t.rendererInfo,o,u,r);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const l=t.filterAttributesData.filter($).map(n=>{const D=m(n,a,r),p={attributeInfo:n.attributeInfo,values:D};return i.push(p),p});f=new Uint32Array(r),r=O(a,e,f,t.filterInfo,l)}for(const l of t.userAttributesData){const n=m(l,a,r);i.push({attributeInfo:l.attributeInfo,values:n})}3*r<e.length&&(e=new Uint8Array(e.buffer.slice(0,3*r))),q(a,r,t.elevationOffset);const b=R(a,r,x.fromData(t.obbData),c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obbData:t.obbData,points:b,rgb:e,attributes:i,pointIdFilterMap:f}}}function R(s,t,a,r,f){if(!M(s,r,0,s,f,0,t))throw new Error("Can't reproject");const i=h(a.center),o=I(),u=I(),e=h(a.halfSize);d(A,a.quaternion);const b=new Float32Array(3*t);for(let l=0;l<t;l++){let n=3*l;o[0]=s[n]-i[0],o[1]=s[n+1]-i[1],o[2]=s[n+2]-i[2],g(u,o,A),e[0]=Math.max(e[0],Math.abs(u[0])),e[1]=Math.max(e[1],Math.abs(u[1])),e[2]=Math.max(e[2],Math.abs(u[2])),b[n++]=o[0],b[n++]=o[1],b[n]=o[2]}return a.halfSize=e,b}function q(s,t,a){if(a!==0)for(let r=0;r<t;r++)s[3*r+2]+=a}const A=y();function P(){return new F}export{P as default};
