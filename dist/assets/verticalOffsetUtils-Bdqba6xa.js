import{ep as c,fy as p,fs as O,f_ as u,f$ as Q,eD as C,eA as T,ex as U,fX as E,g0 as W,eB as Y,g1 as F,ev as Z,fw as ss}from"./index-BfC8i6jT.js";import{_ as N,V as _}from"./sphere-BgvJtIjV.js";import{I as ts,L as rs}from"./orientedBoundingBox-Do1Vt1ct.js";class ps{constructor(){this._transform=T(),this._transformInverse=new b({value:this._transform},U,T),this._transformInverseTranspose=new b(this._transformInverse,E,T),this._transformTranspose=new b({value:this._transform},E,T),this._transformInverseRotation=new b({value:this._transform},W,Y)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(s){F(this._transform,s)}multiplyTransform(s){Z(this._transform,this._transform,s)}set(s){F(this._transform,s),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(s,r){this.setTransformMatrix(s),this.multiplyTransform(r),this._invalidateLazyTransforms()}}class b{constructor(s,r,e){this._original=s,this._update=r,this._dirty=!0,this._transform=e()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}}class es{constructor(s=0){this.offset=s,this.tmpVertex=c()}applyToVertex(s,r,e){const a=O(I,s,r,e),o=ss(P,a,this.localOrigin),i=this.offset/p(o);return u(this.tmpVertex,a,o,i),this.tmpVertex}applyToAabb(s){const r=is,e=os,a=hs;for(let t=0;t<3;++t)r[t]=s[0+t]+this.localOrigin[t],e[t]=s[3+t]+this.localOrigin[t],a[t]=r[t];const o=this.applyToVertex(r[0],r[1],r[2]);for(let t=0;t<3;++t)s[t]=o[t],s[t+3]=o[t];const i=t=>{const n=this.applyToVertex(t[0],t[1],t[2]);for(let l=0;l<3;++l)s[l]=Math.min(s[l],n[l]),s[l+3]=Math.max(s[l+3],n[l])};for(let t=1;t<8;++t){for(let n=0;n<3;++n)a[n]=t&1<<n?e[n]:r[n];i(a)}let f=0;for(let t=0;t<3;++t)r[t]*e[t]<0&&(f|=1<<t);if(f!==0&&f!==7){for(let t=0;t<8;++t)if(!(f&t)){for(let n=0;n<3;++n)a[n]=f&1<<n?0:t&1<<n?r[n]:e[n];i(a)}}for(let t=0;t<3;++t)s[t]-=this.localOrigin[t],s[t+3]-=this.localOrigin[t];return s}}class ns{constructor(s=0){this.componentLocalOriginLength=0,this._totalOffset=0,this._offset=0,this._tmpVertex=c(),this._tmpMbs=N(),this._tmpObb=new ts,this._resetOffset(s)}_resetOffset(s){this._offset=s,this._totalOffset=s}set offset(s){this._resetOffset(s)}get offset(){return this._offset}set componentOffset(s){this._totalOffset=this._offset+s}set localOrigin(s){this.componentLocalOriginLength=p(s)}applyToVertex(s,r,e){const a=O(I,s,r,e),o=O(P,s,r,e+this.componentLocalOriginLength),i=this._totalOffset/p(o);return u(this._tmpVertex,a,o,i),this._tmpVertex}applyToAabb(s){const r=this.componentLocalOriginLength,e=s[0],a=s[1],o=s[2]+r,i=s[3],f=s[4],t=s[5]+r,n=Math.abs(e),l=Math.abs(a),y=Math.abs(o),x=Math.abs(i),d=Math.abs(f),V=Math.abs(t),w=.5*(1+Math.sign(e*i))*Math.min(n,x),$=.5*(1+Math.sign(a*f))*Math.min(l,d),q=.5*(1+Math.sign(o*t))*Math.min(y,V),z=Math.max(n,x),A=Math.max(l,d),R=Math.max(y,V),j=Math.sqrt(w*w+$*$+q*q),B=Math.sign(n+e),D=Math.sign(l+a),G=Math.sign(y+o),S=Math.sign(x+i),X=Math.sign(d+f),k=Math.sign(V+t),m=this._totalOffset;if(j<m)return s[0]-=(1-B)*m,s[1]-=(1-D)*m,s[2]-=(1-G)*m,s[3]+=S*m,s[4]+=X*m,s[5]+=k*m,s;const M=m/Math.sqrt(z*z+A*A+R*R),g=m/j,v=g-M,L=-v;return s[0]+=e*(B*L+g),s[1]+=a*(D*L+g),s[2]+=o*(G*L+g),s[3]+=i*(S*v+M),s[4]+=f*(X*v+M),s[5]+=t*(k*v+M),s}applyToMbs(s){const r=p(_(s)),e=this._totalOffset/r;return u(_(this._tmpMbs),_(s),_(s),e),this._tmpMbs[3]=s[3]+s[3]*this._totalOffset/r,this._tmpMbs}applyToObb(s){return rs(s,this._totalOffset,this._totalOffset,Q.Global,this._tmpObb),this._tmpObb}}class as{constructor(s=0){this.offset=s,this.sphere=N(),this.tmpVertex=c()}applyToVertex(s,r,e){const a=this.objectTransform.transform,o=O(I,s,r,e),i=C(o,o,a),f=this.offset/p(i);u(i,i,i,f);const t=this.objectTransform.inverse;return C(this.tmpVertex,i,t),this.tmpVertex}applyToMinMax(s,r){const e=this.offset/p(s);u(s,s,s,e);const a=this.offset/p(r);u(r,r,r,a)}applyToAabb(s){const r=this.offset/Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);s[0]+=s[0]*r,s[1]+=s[1]*r,s[2]+=s[2]*r;const e=this.offset/Math.sqrt(s[3]*s[3]+s[4]*s[4]+s[5]*s[5]);return s[3]+=s[3]*e,s[4]+=s[4]*e,s[5]+=s[5]*e,s}applyToBoundingSphere(s){const r=p(_(s)),e=this.offset/r;return u(_(this.sphere),_(s),_(s),e),this.sphere[3]=s[3]+s[3]*this.offset/r,this.sphere}}const H=new as;function _s(h){return h!=null?(H.offset=h,H):null}const J=new ns;function cs(h){return h!=null?(J.offset=h,J):null}const K=new es;function us(h){return h!=null?(K.offset=h,K):null}const Ms="terrain",I=c(),P=c(),is=c(),os=c(),hs=c();export{us as I,cs as L,_s as d,ps as v,Ms as w};
