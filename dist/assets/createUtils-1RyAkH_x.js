import{bJ as H,bI as J,hq as q,X as N,aW as O,bH as X,hr as Z,f8 as v,aZ as U,fz as _,ep as E,hs as k,bS as B,bw as C}from"./index-BfC8i6jT.js";import{b as D}from"./Circle-BB08Wuoo.js";import{simplify as F,distance as G}from"./geometryEngine-s82Uc-OG.js";import{w as o}from"./surfaceCoordinateSystems-Bq8REdqh.js";function d(r,t){const s=new C({x:r[0],y:r[1],spatialReference:t});return r.length>2&&(s.z=r[2]),s}function tt(r,t){return new H({points:r,spatialReference:t})}function at(r,t,s){const e=new J({paths:r,spatialReference:t});return s&&q(e),e}function I(r,t,s,e=!0){const l=N(r);l.forEach(n=>{const c=n[0],i=n[n.length-1];O(c,i)&&n.length!==1||n.push(n[0])});let a=new X({rings:l,spatialReference:t});return a.rings.forEach(n=>{Z(n)||n.reverse()}),s&&q(a),e&&a.isSelfIntersecting&&v(t)&&(a=F(a)),a}function nt(r,t,s){const e=t.mapToLocalMultiple(r),l=[],a={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y},c=Math.round(n.x-a.x),i=Math.round(n.y-a.y),x=Math.max(Math.abs(c),Math.abs(i));if(s){const u={x:a.x+x,y:a.y+x},f={x:a.x-x,y:a.y-x};l.push(o(u.x,f.y),o(f.x,f.y),o(f.x,u.y),o(u.x,u.y))}else{const u={x:c>0?a.x+x:a.x-x,y:i>0?a.y+x:a.y-x};l.push(o(a.x,a.y),o(u.x,a.y),o(u.x,u.y),o(a.x,u.y))}return S(I([l.map(u=>t.localToMap(u)).filter(U)],t.spatialReference,t.doUnnormalization,!0),l,t)}function et(r,t,s){let e=t.mapToLocalMultiple(r);if(e.length===1){const i=e[0];e=[o(i.x-48,i.y+48),o(i.x+48,i.y-48),o(i.x+48,i.y-48),o(i.x-48,i.y+48)]}const l=[],a={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y};if(s){const c=Math.round(n.x-a.x),i=Math.round(n.y-a.y);l.push(o(a.x-c,a.y-i),o(n.x,a.y-i),o(n.x,n.y),o(a.x-c,n.y))}else l.push(o(a.x,a.y),o(n.x,a.y),o(n.x,n.y),o(a.x,n.y));return S(I([l.map(c=>t.localToMap(c)).filter(U)],t.spatialReference,t.doUnnormalization,!0),l,t)}function S(r,t,s){const e=z(t[3],t[2],s),l=z(t[1],t[2],s),a=z(t[0],t[1],s),n=z(t[0],t[3],s);return{geometry:r,midpoints:e!=null&&l!=null&&a!=null&&n!=null?{top:e,right:l,bottom:a,left:n}:null}}function z(r,t,s){T[0]=r.x,T[1]=r.y,T[2]=0,g[0]=t.x,g[1]=t.y,g[2]=0,_(T,T,g,.5),$.x=T[0],$.y=g[1],$.z=g[2];const e=s.localToMap($);return e!=null?d(e,s.spatialReference):null}const $=o(0,0,0),T=E(),g=E();function lt(r,t,s,e){const l=t.mapToLocalMultiple(r);let a=null,n=null;if(s)a=l[0],n=l[1];else{const y=l[0],p=l[1],b=Math.round(p.x-y.x),R=Math.round(p.y-y.y),h=Math.max(Math.abs(b),Math.abs(R));a=o(b>0?y.x+h/2:y.x-h/2,R>0?y.y+h/2:y.y-h/2),n=o(Math.abs(b)>Math.abs(R)?a.x-h/2:a.x,Math.abs(b)>Math.abs(R)?a.y:a.y-h/2)}const c=t.localToMap(a),i=t.localToMap(n);if(c==null||i==null)return null;t.doUnnormalization&&k([[c,i]],t.spatialReference);const x=d(c,t.spatialReference),u=d(i,t.spatialReference),f=B(t.spatialReference);let M=0;if(v(t.spatialReference))M=f*G(x,u,null);else{const y=a.x-n.x,p=a.y-n.y;M=f*Math.sqrt(y*y+p*p)*(e||1)}const w=new D({center:x,radius:M,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:I(w.rings,w.spatialReference,!1),center:x,edge:u}}function st(r,t,s){const e=t.mapToLocalMultiple(r),l=e[0],a=e[1],n=Math.round(a.x-l.x),c=Math.round(a.y-l.y),i=o(s?l.x:l.x+n/2,s?l.y:l.y+c/2),x=s?n:n/2,u=s?c:c/2,f=60,M=[],w=2*Math.PI/f;function y(m){const W=Math.cos(m),A=Math.sin(m);return o(x*W+i.x,u*A+i.y)}for(let m=0;m<f;m++)M.push(y(m*w));M.push(M[0]);const{spatialReference:p,doUnnormalization:b}=t,R=I([M.map(m=>t.localToMap(m)).filter(U)],p,b,!1),h=t.localToMap(y(Math.PI/2)),P=t.localToMap(y(0)),L=t.localToMap(y(-Math.PI/2)),j=t.localToMap(y(Math.PI));return{geometry:R,midpoints:h!=null&&P!=null&&L!=null&&j!=null?{top:d(h,p),right:d(P,p),bottom:d(L,p),left:d(j,p)}:null}}export{lt as L,at as R,nt as T,et as b,tt as d,I as j,st as v};
