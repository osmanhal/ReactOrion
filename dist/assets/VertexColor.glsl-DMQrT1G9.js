import{aJ as ie,io as Ue,fs as ee,ep as J,oh as Ge,aE as Je,pA as Me,pB as Te,fF as Re,dy as We,hP as oe,pC as Ke,pD as Ye,fB as xe,ft as Le,eq as Ne}from"./index-BfC8i6jT.js";import{n as Xe,o as T}from"./interfaces-B8ge7Jg9.js";import{a as _e}from"./basicInterfaces-wONHx_SN.js";import{n as Qe,v as Ze,q as et,f as tt,b as rt,u as st}from"./Texture-1xthaLvE.js";import{o as ce,h as Be}from"./Matrix4PassUniform-BH4JqvtO.js";import{e as it}from"./Material-CL7oq3ds.js";import{s as E}from"./Util-D9KK83cB.js";import{e as I}from"./VertexAttribute-BnAa5VW0.js";import{x as Ee,c as Fe,y as nt,u as ot,q as at,i as Pe}from"./BufferView-DcMGflLe.js";let Gt=class extends Qe{constructor(t){super(t),this._numLoading=0,this._disposed=!1,this._textures=t.textures,this._textureId=t.textureId,this._acquire(t.textureId,i=>this._texture=i),this._acquire(t.normalTextureId,i=>this._textureNormal=i),this._acquire(t.emissiveTextureId,i=>this._textureEmissive=i),this._acquire(t.occlusionTextureId,i=>this._textureOcclusion=i),this._acquire(t.metallicRoughnessTextureId,i=>this._textureMetallicRoughness=i)}dispose(){this._texture=ie(this._texture),this._textureNormal=ie(this._textureNormal),this._textureEmissive=ie(this._textureEmissive),this._textureOcclusion=ie(this._textureOcclusion),this._textureMetallicRoughness=ie(this._textureMetallicRoughness),this._disposed=!0}ensureResources(t){return this._numLoading===0?_e.LOADED:_e.LOADING}get textureBindParameters(){return new ct(this._texture!=null?this._texture.glTexture:null,this._textureNormal!=null?this._textureNormal.glTexture:null,this._textureEmissive!=null?this._textureEmissive.glTexture:null,this._textureOcclusion!=null?this._textureOcclusion.glTexture:null,this._textureMetallicRoughness!=null?this._textureMetallicRoughness.glTexture:null)}updateTexture(t){this._texture!=null&&t===this._texture.id||(this._texture=ie(this._texture),this._textureId=t,this._acquire(this._textureId,i=>this._texture=i))}_acquire(t,i){if(t==null)return void i(null);const r=this._textures.acquire(t);if(Ue(r))return++this._numLoading,void r.then(a=>{if(this._disposed)return ie(a),void i(null);i(a)}).finally(()=>--this._numLoading);i(r)}};class ct extends Xe{constructor(t=null,i=null,r=null,a=null,s=null,n,o){super(),this.texture=t,this.textureNormal=i,this.textureEmissive=r,this.textureOcclusion=a,this.textureMetallicRoughness=s,this.scale=n,this.normalTextureTransformMatrix=o}}function Ce(e){e.varyings.add("linearDepth","float")}function lt(e){e.vertex.uniforms.add(new et("nearFar",(t,i)=>i.camera.nearFar))}function Ie(e){e.vertex.code.add(T`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`)}function Wt(e,t){const{vertex:i}=e;switch(t.output){case ce.Color:if(t.receiveShadows)return Ce(e),void i.code.add(T`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);break;case ce.Shadow:case ce.ShadowHighlight:case ce.ShadowExcludeHighlight:case ce.ViewshedShadow:return e.include(Ze,t),Ce(e),lt(e),Ie(e),void i.code.add(T`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`)}i.code.add(T`void forwardLinearDepth() {}`)}function Kt(e){Ie(e),e.vertex.code.add(T`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),e.vertex.code.add(T`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function ut(e){e.vertex.code.add(T`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`),e.vertex.code.add(T`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`),e.vertex.code.add(T`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),e.vertex.code.add(T`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`),e.vertex.code.add(T`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),e.vertex.code.add(T`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`)}function Yt(e){e.uniforms.add(new Be("screenSizePerspective",t=>Ve(t.screenSizePerspective)))}function ft(e){e.uniforms.add(new Be("screenSizePerspectiveAlignment",t=>Ve(t.screenSizePerspectiveAlignment||t.screenSizePerspective)))}function Ve(e){return ee(dt,e.parameters.divisor,e.parameters.offset,e.minScaleFactor)}const dt=J();function Xt(e,t){const i=e.vertex;t.hasVerticalOffset?(pt(i),t.hasScreenSizePerspective&&(e.include(ut),ft(i),tt(e.vertex,t)),i.code.add(T`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${t.spherical?T`vec3 worldNormal = normalize(worldPos + localOrigin);`:T`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${t.hasScreenSizePerspective?T`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:T`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)):i.code.add(T`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}const ht=Je();function pt(e){e.uniforms.add(new rt("verticalOffset",(t,i)=>{const{minWorldLength:r,maxWorldLength:a,screenLength:s}=t.verticalOffset,n=Math.tan(.5*i.camera.fovY)/(.5*i.camera.fullViewport[3]),o=i.camera.pixelRatio||1;return Ge(ht,s*o,n,r,a)}))}function Qt(e,t,i,r=1){const{data:a,indices:s}=e,n=t.typedBuffer,o=t.typedBufferStride,c=s.length;if(i*=o,r===1)for(let u=0;u<c;++u)n[i]=a[s[u]],i+=o;else for(let u=0;u<c;++u){const l=a[s[u]];for(let f=0;f<r;f++)n[i]=l,i+=o}}function Ae(e,t,i){const{data:r,indices:a}=e,s=t.typedBuffer,n=t.typedBufferStride,o=a.length;i*=n;for(let c=0;c<o;++c){const u=2*a[c];s[i]=r[u],s[i+1]=r[u+1],i+=n}}function qe(e,t,i,r){const{data:a,indices:s}=e,n=t.typedBuffer,o=t.typedBufferStride,c=s.length;if(i*=o,r==null||r===1)for(let u=0;u<c;++u){const l=3*s[u];n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],i+=o}else for(let u=0;u<c;++u){const l=3*s[u];for(let f=0;f<r;++f)n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],i+=o}}function De(e,t,i,r=1){const{data:a,indices:s}=e,n=t.typedBuffer,o=t.typedBufferStride,c=s.length;if(i*=o,r===1)for(let u=0;u<c;++u){const l=4*s[u];n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],n[i+3]=a[l+3],i+=o}else for(let u=0;u<c;++u){const l=4*s[u];for(let f=0;f<r;++f)n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],n[i+3]=a[l+3],i+=o}}function Zt(e,t,i){const r=e.typedBuffer,a=e.typedBufferStride;t*=a;for(let s=0;s<i;++s)r[t]=0,r[t+1]=0,r[t+2]=0,r[t+3]=0,t+=a}function vt(e,t,i,r,a=1){if(!t)return void qe(e,i,r,a);const{data:s,indices:n}=e,o=i.typedBuffer,c=i.typedBufferStride,u=n.length,l=t[0],f=t[1],w=t[2],B=t[4],A=t[5],R=t[6],S=t[8],L=t[9],_=t[10],F=t[12],P=t[13],y=t[14];r*=c;let O=0,p=0,h=0;const g=Me(t)?x=>{O=s[x]+F,p=s[x+1]+P,h=s[x+2]+y}:x=>{const d=s[x],m=s[x+1],v=s[x+2];O=l*d+B*m+S*v+F,p=f*d+A*m+L*v+P,h=w*d+R*m+_*v+y};if(a===1)for(let x=0;x<u;++x)g(3*n[x]),o[r]=O,o[r+1]=p,o[r+2]=h,r+=c;else for(let x=0;x<u;++x){g(3*n[x]);for(let d=0;d<a;++d)o[r]=O,o[r+1]=p,o[r+2]=h,r+=c}}function xt(e,t,i,r,a=1){if(!t)return void qe(e,i,r,a);const{data:s,indices:n}=e,o=t,c=i.typedBuffer,u=i.typedBufferStride,l=n.length,f=o[0],w=o[1],B=o[2],A=o[4],R=o[5],S=o[6],L=o[8],_=o[9],F=o[10],P=!Te(o),y=1e-6,O=1-y;r*=u;let p=0,h=0,g=0;const x=Me(o)?d=>{p=s[d],h=s[d+1],g=s[d+2]}:d=>{const m=s[d],v=s[d+1],z=s[d+2];p=f*m+A*v+L*z,h=w*m+R*v+_*z,g=B*m+S*v+F*z};if(a===1)if(P)for(let d=0;d<l;++d){x(3*n[d]);const m=p*p+h*h+g*g;if(m<O&&m>y){const v=1/Math.sqrt(m);c[r]=p*v,c[r+1]=h*v,c[r+2]=g*v}else c[r]=p,c[r+1]=h,c[r+2]=g;r+=u}else for(let d=0;d<l;++d)x(3*n[d]),c[r]=p,c[r+1]=h,c[r+2]=g,r+=u;else for(let d=0;d<l;++d){if(x(3*n[d]),P){const m=p*p+h*h+g*g;if(m<O&&m>y){const v=1/Math.sqrt(m);p*=v,h*=v,g*=v}}for(let m=0;m<a;++m)c[r]=p,c[r+1]=h,c[r+2]=g,r+=u}}function mt(e,t,i,r,a=1){if(!t)return void De(e,i,r,a);const{data:s,indices:n}=e,o=t,c=i.typedBuffer,u=i.typedBufferStride,l=n.length,f=o[0],w=o[1],B=o[2],A=o[4],R=o[5],S=o[6],L=o[8],_=o[9],F=o[10],P=!Te(o),y=1e-6,O=1-y;if(r*=u,a===1)for(let p=0;p<l;++p){const h=4*n[p],g=s[h],x=s[h+1],d=s[h+2],m=s[h+3];let v=f*g+A*x+L*d,z=w*g+R*x+_*d,$=B*g+S*x+F*d;if(P){const b=v*v+z*z+$*$;if(b<O&&b>y){const C=1/Math.sqrt(b);v*=C,z*=C,$*=C}}c[r]=v,c[r+1]=z,c[r+2]=$,c[r+3]=m,r+=u}else for(let p=0;p<l;++p){const h=4*n[p],g=s[h],x=s[h+1],d=s[h+2],m=s[h+3];let v=f*g+A*x+L*d,z=w*g+R*x+_*d,$=B*g+S*x+F*d;if(P){const b=v*v+z*z+$*$;if(b<O&&b>y){const C=1/Math.sqrt(b);v*=C,z*=C,$*=C}}for(let b=0;b<a;++b)c[r]=v,c[r+1]=z,c[r+2]=$,c[r+3]=m,r+=u}}function gt(e,t,i,r,a=1){const{data:s,indices:n}=e,o=i.typedBuffer,c=i.typedBufferStride,u=n.length;if(r*=c,t!==s.length||t!==4)if(a!==1)if(t!==4)for(let l=0;l<u;++l){const f=3*n[l];for(let w=0;w<a;++w)o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=255,r+=c}else for(let l=0;l<u;++l){const f=4*n[l];for(let w=0;w<a;++w)o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=s[f+3],r+=c}else{if(t===4){for(let l=0;l<u;++l){const f=4*n[l];o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=s[f+3],r+=c}return}for(let l=0;l<u;++l){const f=3*n[l];o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=255,r+=c}}else{o[r]=s[0],o[r+1]=s[1],o[r+2]=s[2],o[r+3]=s[3];const l=new Uint32Array(i.typedBuffer.buffer,i.start),f=c/4,w=l[r/=4];r+=f;const B=u*a;for(let A=1;A<B;++A)l[r]=w,r+=f}}function St(e,t,i){const{data:r,indices:a}=e,s=t.typedBuffer,n=t.typedBufferStride,o=a.length,c=r[0];i*=n;for(let u=0;u<o;++u)s[i]=c,i+=n}function wt(e,t,i,r,a=1){const s=t.typedBuffer,n=t.typedBufferStride;if(r*=n,a===1)for(let o=0;o<i;++o)s[r]=e[0],s[r+1]=e[1],s[r+2]=e[2],s[r+3]=e[3],r+=n;else for(let o=0;o<i;++o)for(let c=0;c<a;++c)s[r]=e[0],s[r+1]=e[1],s[r+2]=e[2],s[r+3]=e[3],r+=n}function zt(e,t,i,r,a,s){var n;for(const o of t.fields.keys()){const c=e.attributes.get(o),u=c==null?void 0:c.indices;if(c&&u)Ot(o,c,i,r,a,s);else if(o===I.OBJECTANDLAYERIDCOLOR&&e.objectAndLayerIdColor!=null){const l=(n=e.attributes.get(I.POSITION))==null?void 0:n.indices;if(l){const f=l.length,w=a.getField(o,Ee);wt(e.objectAndLayerIdColor,w,f,s)}}}}function Ot(e,t,i,r,a,s){switch(e){case I.POSITION:{E(t.size===3);const n=a.getField(e,Pe);E(!!n,`No buffer view for ${e}`),n&&vt(t,i,n,s);break}case I.NORMAL:{E(t.size===3);const n=a.getField(e,Pe);E(!!n,`No buffer view for ${e}`),n&&xt(t,r,n,s);break}case I.NORMALCOMPRESSED:{E(t.size===2);const n=a.getField(e,at);E(!!n,`No buffer view for ${e}`),n&&Ae(t,n,s);break}case I.UV0:{E(t.size===2);const n=a.getField(e,ot);E(!!n,`No buffer view for ${e}`),n&&Ae(t,n,s);break}case I.COLOR:case I.SYMBOLCOLOR:{const n=a.getField(e,Ee);E(!!n,`No buffer view for ${e}`),E(t.size===3||t.size===4),!n||t.size!==3&&t.size!==4||gt(t,t.size,n,s);break}case I.COLORFEATUREATTRIBUTE:{const n=a.getField(e,nt);E(!!n,`No buffer view for ${e}`),E(t.size===1),n&&t.size===1&&St(t,n,s);break}case I.TANGENT:{E(t.size===4);const n=a.getField(e,Fe);E(!!n,`No buffer view for ${e}`),n&&mt(t,i,n,s);break}case I.PROFILERIGHT:case I.PROFILEUP:case I.PROFILEVERTEXANDNORMAL:case I.FEATUREVALUE:{E(t.size===4);const n=a.getField(e,Fe);E(!!n,`No buffer view for ${e}`),n&&De(t,n,s)}}}const $t=Re(1,1,0,1),bt=Re(1,0,1,1);function er(e){e.fragment.uniforms.add(new st("depthTexture",(t,i)=>i.mainDepth)),e.fragment.constants.add("occludedHighlightFlag","vec4",$t).add("unoccludedHighlightFlag","vec4",bt),e.fragment.code.add(T`void outputHighlight() {
float sceneDepth = float(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x);
if (gl_FragCoord.z > sceneDepth + 5e-7) {
fragColor = occludedHighlightFlag;
} else {
fragColor = unoccludedHighlightFlag;
}
}`)}class yt{constructor(t=!1,i=!0){this.isVerticalRay=t,this.normalRequired=i}}const ue=We();function tr(e,t,i,r,a,s){if(!e.visible)return;const n=oe(je,r,i),o=(u,l,f)=>{s(u,f,l,!1)},c=new yt(!1,t.options.normalRequired);if(e.boundingInfo){E(e.type===it.Mesh);const u=t.tolerance;ke(e.boundingInfo,i,n,u,a,c,o)}else{const u=e.attributes.get(I.POSITION),l=u.indices;He(i,n,0,l.length/3,l,u.data,u.stride,a,c,o)}}const _t=J();function ke(e,t,i,r,a,s,n){if(e==null)return;const o=Tt(i,_t);if(Ke(ue,e.bbMin),Ye(ue,e.bbMax),a!=null&&a.applyToAabb(ue),Rt(ue,t,o,r)){const{primitiveIndices:c,position:u}=e,l=c?c.length:u.indices.length/3;if(l>Nt){const f=e.getChildren();if(f!==void 0){for(const w of f)ke(w,t,i,r,a,s,n);return}}Ft(t,i,0,l,u.indices,u.data,u.stride,c,a,s,n)}}const ne=J();function rr(e,t,i,r,a,s,n,o,c){const{data:u,stride:l}=s;He(e,oe(je,t,e),i,r,a,u,l,n,o,c)}function sr(e,t,i,r,a,s,n,o,c,u=null,l=0){const f=e[0],w=e[1],B=e[2],A=t[0],R=t[1],S=t[2];for(let L=i;L<r;++L){const _=l+(u?u[L]:L),F=3*_,P=n*a[F],y=s[P],O=s[P+1],p=s[P+2],h=n*a[F+1],g=s[h],x=s[h+1],d=s[h+2],m=n*a[F+2],v=g-y,z=x-O,$=d-p,b=s[m]-y,C=s[m+1]-O,V=s[m+2]-p,H=R*V-C*S,j=S*b-V*A,U=A*C-b*R,M=v*H+z*j+$*U;if(Math.abs(M)<=ge)continue;const D=f-y,k=w-O,G=B-p,N=D*H+k*j+G*U;if(M>0){if(N<0||N>M)continue}else if(N>0||N<M)continue;const W=k*$-z*G,K=G*v-$*D,Y=D*z-v*k,q=A*W+R*K+S*Y;if(M>0){if(q<0||N+q>M)continue}else if(q>0||N+q<M)continue;const X=(b*W+C*K+V*Y)/M;X>=0&&c(X,_,o?me(v,z,$,b,C,V,ne):null)}}function ir(e,t,i,r,a,s,n,o,c,u,l,f=null,w=0){const B=e[0],A=e[1],R=e[2],S=t[0],L=t[1],_=t[2];for(let F=i;F<r;++F){const P=w+(f?f[F]:F),y=3*P,O=n*a[y],p=s[O],h=s[O+1],g=s[O+2],x=n*a[y+1],d=s[x],m=s[x+1],v=s[x+2],z=n*a[y+2],$=s[z],b=s[z+1],C=s[z+2],V=g-c,H=o/Math.sqrt(p*p+h*h+V*V),j=p+p*H,U=h+h*H,M=g+V*H,D=v-c,k=o/Math.sqrt(d*d+m*m+D*D),G=d+d*k,N=m+m*k,W=v+D*k,K=C-c,Y=o/Math.sqrt($*$+b*b+K*K),q=G-j,X=N-U,te=W-M,re=$+$*Y-j,Q=b+b*Y-U,se=C+K*Y-M,Se=L*se-Q*_,we=_*re-se*S,ze=S*Q-re*L,Z=q*Se+X*we+te*ze;if(Math.abs(Z)<=ge)continue;const he=B-j,pe=A-U,ve=R-M,ae=he*Se+pe*we+ve*ze;if(Z>0){if(ae<0||ae>Z)continue}else if(ae>0||ae<Z)continue;const Oe=pe*te-X*ve,$e=ve*q-te*he,be=he*X-q*pe,le=S*Oe+L*$e+_*be;if(Z>0){if(le<0||ae+le>Z)continue}else if(le>0||ae+le<Z)continue;const ye=(re*Oe+Q*$e+se*be)/Z;ye>=0&&l(ye,P,u?me(q,X,te,re,Q,se,ne):null)}}function Ft(e,t,i,r,a,s,n,o,c,u,l){const f=e[0],w=e[1],B=e[2],A=t[0],R=t[1],S=t[2],{normalRequired:L}=u;for(let _=i;_<r;++_){const F=o[_],P=3*F,y=n*a[P];let O=s[y],p=s[y+1],h=s[y+2];const g=n*a[P+1];let x=s[g],d=s[g+1],m=s[g+2];const v=n*a[P+2];let z=s[v],$=s[v+1],b=s[v+2];c!=null&&([O,p,h]=c.applyToVertex(O,p,h,_),[x,d,m]=c.applyToVertex(x,d,m,_),[z,$,b]=c.applyToVertex(z,$,b,_));const C=x-O,V=d-p,H=m-h,j=z-O,U=$-p,M=b-h,D=R*M-U*S,k=S*j-M*A,G=A*U-j*R,N=C*D+V*k+H*G;if(Math.abs(N)<=ge)continue;const W=f-O,K=w-p,Y=B-h,q=W*D+K*k+Y*G;if(N>0){if(q<0||q>N)continue}else if(q>0||q<N)continue;const X=K*H-V*Y,te=Y*C-H*W,re=W*V-C*K,Q=A*X+R*te+S*re;if(N>0){if(Q<0||q+Q>N)continue}else if(Q>0||q+Q<N)continue;const se=(j*X+U*te+M*re)/N;se>=0&&l(se,F,L?me(C,V,H,j,U,M,ne):null)}}function He(e,t,i,r,a,s,n,o,c,u){const l=t,f=Bt,w=Math.abs(l[0]),B=Math.abs(l[1]),A=Math.abs(l[2]),R=w>=B?w>=A?0:2:B>=A?1:2,S=R,L=l[S]<0?2:1,_=(R+L)%3,F=(R+(3-L))%3,P=l[_]/l[S],y=l[F]/l[S],O=1/l[S],p=Pt,h=Ct,g=At,{normalRequired:x}=c;for(let d=i;d<r;++d){const m=3*d,v=n*a[m];ee(f[0],s[v+0],s[v+1],s[v+2]);const z=n*a[m+1];ee(f[1],s[z+0],s[z+1],s[z+2]);const $=n*a[m+2];ee(f[2],s[$+0],s[$+1],s[$+2]),o&&(xe(f[0],o.applyToVertex(f[0][0],f[0][1],f[0][2],d)),xe(f[1],o.applyToVertex(f[1][0],f[1][1],f[1][2],d)),xe(f[2],o.applyToVertex(f[2][0],f[2][1],f[2][2],d))),oe(p,f[0],e),oe(h,f[1],e),oe(g,f[2],e);const b=p[_]-P*p[S],C=p[F]-y*p[S],V=h[_]-P*h[S],H=h[F]-y*h[S],j=g[_]-P*g[S],U=g[F]-y*g[S],M=j*H-U*V,D=b*U-C*j,k=V*C-H*b;if((M<0||D<0||k<0)&&(M>0||D>0||k>0))continue;const G=M+D+k;if(G===0)continue;const N=M*(O*p[S])+D*(O*h[S])+k*(O*g[S]);if(N*Math.sign(G)<0)continue;const W=N/G;W>=0&&u(W,d,x?Mt(f):null)}}const Pt=J(),Ct=J(),At=J();function me(e,t,i,r,a,s,n){return ee(fe,e,t,i),ee(de,r,a,s),Le(n,fe,de),Ne(n,n),n}function Mt(e){return oe(fe,e[1],e[0]),oe(de,e[2],e[0]),Le(ne,fe,de),Ne(ne,ne),ne}const fe=J(),de=J();function nr(e,t,i){return ee(i,1/(t[0]-e[0]),1/(t[1]-e[1]),1/(t[2]-e[2]))}function Tt(e,t){return ee(t,1/e[0],1/e[1],1/e[2])}function Rt(e,t,i,r){return Lt(e,t,i,r,1/0)}function Lt(e,t,i,r,a){const s=(e[0]-r-t[0])*i[0],n=(e[3]+r-t[0])*i[0];let o=Math.min(s,n),c=Math.max(s,n);const u=(e[1]-r-t[1])*i[1],l=(e[4]+r-t[1])*i[1];if(c=Math.min(c,Math.max(u,l)),c<0||(o=Math.max(o,Math.min(u,l)),o>c))return!1;const f=(e[2]-r-t[2])*i[2],w=(e[5]+r-t[2])*i[2];return c=Math.min(c,Math.max(f,w)),!(c<0)&&(o=Math.max(o,Math.min(f,w)),!(o>c)&&o<a)}const Nt=1e3,ge=1e-7,je=J(),Bt=[J(),J(),J()];class or{constructor(t){this.vertexBufferLayout=t}elementCount(t){return t.attributes.get(I.POSITION).indices.length}write(t,i,r,a,s){zt(r,this.vertexBufferLayout,t,i,a,s)}}function ar(e,t){t.hasVertexColors?(e.attributes.add(I.COLOR,"vec4"),e.varyings.add("vColor","vec4"),e.vertex.code.add(T`void forwardVertexColor() { vColor = color; }`),e.vertex.code.add(T`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)):e.vertex.code.add(T`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}export{Ot as A,ir as B,nr as C,zt as E,xt as O,wt as R,gt as S,er as a,vt as b,Xt as c,Qt as d,ar as e,pt as f,ft as g,$t as h,lt as i,bt as j,De as k,ct as l,yt as m,Wt as n,Kt as o,tr as p,Rt as q,or as r,ut as s,Yt as t,Gt as u,Ce as v,Lt as w,rr as x,Zt as y,sr as z};
