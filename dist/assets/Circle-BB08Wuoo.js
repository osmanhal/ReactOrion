import{v as n,y as h,bw as u,z as g,bH as p,cb as f,hl as b,hm as m,hn as w,h0 as y,ho as R,hp as C,g3 as k,aR as M}from"./index-BfC8i6jT.js";import{b as P}from"./geodesicUtils-BOUsTR0r.js";var l;let c=l=class extends p{constructor(...e){super(...e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}normalizeCtorArgs(e,a){let i;if(e!=null&&e.center)i=e;else{if(e!=null&&e.rings)return super.normalizeCtorArgs(e,a);i={center:e}}return{...super.normalizeCtorArgs(),...i,...a}}initialize(){const e=this.center,a=this.numberOfPoints;if(this.hasZ=(e==null?void 0:e.hasZ)??!1,this.rings.length!==0||!e)return;const i=f(this.radius,this.radiusUnit,"meters"),r=e.spatialReference;let t,s="geographic";if(r.isWebMercator?s="webMercator":((r.wkid&&b[r.wkid])!=null||(r.wkt2||r.wkt)&&m(r.wkt2||r.wkt))&&(s="projected"),this.geodesic){let o;switch(s){case"webMercator":o=w(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":o=e}t=this._createGeodesicCircle(o,i,a),s==="webMercator"&&(t=y(t))}else{let o;s==="webMercator"||s==="projected"?o=i/R(e.spatialReference):s==="geographic"&&(o=C(i,"meters",k(e.spatialReference).radius)),t=this._createPlanarCircle(e,o,a)}this.spatialReference=t.spatialReference,this.addRing(t.rings[0])}clone(){const{center:e,numberOfPoints:a,radius:i,radiusUnit:r,geodesic:t}=this;return new l({center:e==null?void 0:e.clone(),numberOfPoints:a,radius:i,radiusUnit:r,geodesic:t})}_createGeodesicCircle(e,a,i){let r=0;const t=[];for(;r<360;){const s=[0,0],o=[e.x,e.y];P(s,o,r,a,M.WGS84),this.hasZ&&s.push(e.z),t.push(s),r+=360/i}return t.push(t[0]),new p(t)}_createPlanarCircle(e,a,i){const r=[],t=2*Math.PI/i;for(let s=0;s<i;++s){const o=t*s,d=[e.x+Math.cos(-o)*a,e.y+Math.sin(-o)*a];this.hasZ&&d.push(e.z),r.push(d)}return r.push(r[0]),new p({spatialReference:e.spatialReference,rings:[r]})}};n([h({type:u})],c.prototype,"center",void 0),n([h()],c.prototype,"geodesic",void 0),n([h()],c.prototype,"numberOfPoints",void 0),n([h()],c.prototype,"radius",void 0),n([h()],c.prototype,"radiusUnit",void 0),c=l=n([g("esri.geometry.Circle")],c);const j=c;export{j as b};
