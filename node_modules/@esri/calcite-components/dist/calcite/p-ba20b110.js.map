{"version":3,"names":["now","Date","startDate","toISOString","daysInYear","groupDateRange","defaultGroupingOptions","_getDates","numberDays","dateEngine","dateArray","date","create","i","increase","push","formatToIsoDateString","generateTimeZoneMetadata","timeZoneItems","processedDates","Map","theDates","map","tzItem","label","continent","extractContinent","dates","key","utc","get","isoToTimeZone","set","isRegularContinent","compareDateArrs","array1","array2","length","every","value","index","same","getGroupLabelTimeZoneIndices","rawTZs","max","shrinkedTzs","filter","validLabels","tz","indexOf","equallyDistributedSampling","items","maxItems","totalItems","numberItemsToSelect","Math","min","stepSize","Array","from","_","round","async","groupByOffset","options","grouping","Error","timeZones","timeZoneMetadata","tzMetadatumI","visited","newGroup","labelIdx","tzs","tzMetadatumJ","labelJ","continentJ","isRegularContinentJ","datesJ","group","sort","a","b","localeCompare","labelTzIdx"],"sources":["node_modules/timezone-groups/dist/groupByOffset/index.mjs"],"sourcesContent":["import { timeZones } from '../utils/time-zones.mjs';\nimport { extractContinent, isRegularContinent } from '../utils/continent.mjs';\n\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n    groupDateRange,\n    startDate,\n};\n\nconst _getDates = (startDate, numberDays, dateEngine) => {\n    const dateArray = [];\n    let date = dateEngine.create(startDate);\n    for (let i = 0; i <= numberDays; i++) {\n        date = dateEngine.increase(date);\n        dateArray.push(dateEngine.formatToIsoDateString(date));\n    }\n    return dateArray;\n};\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine) => {\n    const processedDates = new Map();\n    const theDates = _getDates(startDate, numberDays, dateEngine);\n    return timeZoneItems.map((tzItem) => {\n        const { label } = tzItem;\n        const continent = extractContinent(label);\n        const dates = theDates.map((date) => {\n            const key = `${date}-${label}`;\n            let utc = processedDates.get(key);\n            if (utc) {\n                return utc;\n            }\n            utc = dateEngine.isoToTimeZone(date, label);\n            processedDates.set(key, utc);\n            return utc;\n        });\n        return {\n            ...tzItem,\n            continent,\n            isRegularContinent: isRegularContinent(continent),\n            dates,\n        };\n    });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&\n    array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n    const shrinkedTzs = rawTZs.filter(({ label }) => isRegularContinent(extractContinent(label)));\n    if (shrinkedTzs.length === 0) {\n        return [0];\n    }\n    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));\n    return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n    const totalItems = items.length;\n    if (totalItems <= maxItems) {\n        return items;\n    }\n    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n    return [\n        items[0],\n        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),\n        items[totalItems - 1],\n    ];\n}\n\nasync function groupByOffset(options) {\n    const { groupDateRange, startDate, dateEngine } = {\n        ...defaultGroupingOptions,\n        ...options,\n    };\n    const grouping = [];\n    if (!dateEngine) {\n        throw new Error('dateEngine is required');\n    }\n    const timeZoneItems = timeZones.map((tz) => ({ label: tz }));\n    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine);\n    // We traverse the mappedDB and see if we find matches by comparing each set\n    // of transformed date for that specific TZ.\n    for (const tzMetadatumI of timeZoneMetadata) {\n        const { label, continent, dates } = tzMetadatumI;\n        if (tzMetadatumI.visited) {\n            continue;\n        }\n        tzMetadatumI.visited = true;\n        const newGroup = {\n            labelIdx: [],\n            tzs: [{ label }],\n        };\n        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {\n            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;\n            // We define a matching TZ by:\n            // 1) if both continents match (avoid grouping Antarctica with anything else)\n            // 2) if the transformed dates match in both TZs\n            if ((continent === continentJ || !isRegularContinentJ) &&\n                compareDateArrs(dates, datesJ, dateEngine)) {\n                const tzItem = { label: labelJ };\n                newGroup.tzs.push(tzItem);\n                tzMetadatumJ.visited = true;\n            }\n        }\n        grouping.push(newGroup);\n    }\n    // Now that we have a group, we want an easy way to find a fitting label for the group\n    // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n    return grouping\n        .map((group) => {\n        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n        return {\n            labelTzIdx: getGroupLabelTimeZoneIndices(group.tzs, 7),\n            tzs: group.tzs.map((_) => _.label),\n        };\n    })\n        .sort((a, b) => b.tzs.length - a.tzs.length);\n}\n\nexport { groupByOffset };\n"],"mappings":"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","ignoreList":[]}