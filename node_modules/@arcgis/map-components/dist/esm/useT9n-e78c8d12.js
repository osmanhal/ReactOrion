/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.7
 */
import { p as proxyExports, A as AccessorController, a as accessorSupport } from './index-c99fc80c.js';
import './index-d2df902e.js';
import { a as attachToParent } from './component-utils-de9339fe.js';
import { m as makeT9nController } from './chunk-PVEVZB4O-2c3b8893.js';
import { a as getAssetPath } from './index-7d33cc26.js';

/**
 * A controller for a mapping component that:
 * - loads the viewModel
 * - initializes the viewModel with the component's properties
 * - does two-way binding between view model and component properties
 * - re-emits the viewModel's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/main/packages/map-components/src/controllers/useViewModel.md
 */
const makeViewModelController = (loadViewModel, _options) => (component, options) => proxy(component, loadViewModel, options);
// REFACTOR: extract common logic into IntegrationController???
class ViewModelController extends AccessorController {
    hostConnected() {
        if (this.component.manager.didLoadCalled) {
            attachToParent(this.component);
        }
    }
    async hostLoad() {
        await super.hostLoad();
        if (this.component.manager.destroyed) {
            return;
        }
        this._watchMetaProperties();
        accessorSupport.reEmitAccessorEvents(this, this._instance, this.reactiveUtils, "viewModel");
    }
    hostLoaded() {
        const { el } = this.component;
        const childNode = el.shadowRoot?.firstElementChild ?? el.firstElementChild ?? undefined;
        /*
         * On hot reloading, new this.component instance is created (so properties
         * on it are reset) but this.component.el instance is preserved (so
         * properties on it are preserved). Since childElem is re-parented on 1st
         * hostLoad(), for it to be accessible on the 2nd hostLoad() (hot reload),
         * we have to store it's reference on the el, rather than component
         */
        el.childElem = childNode ?? el.childElem;
        if (el.childElem === undefined && "production" !== "production") {
            throw new Error("Unable to find component's root child");
        }
        let arcgisReadyEmitted = false;
        // Check if view was already provided by the user
        const currentView = this.component.el.view;
        // Define the "view" property to allow component usage with MapView/SceneView
        Object.defineProperty(this.component.el, "view", {
            get: () => this._instance.view,
            set: (view) => {
                this._instance.view = view;
                this._watchViewDestroy();
                this.component.requestUpdate();
                if (!arcgisReadyEmitted) {
                    arcgisReadyEmitted = true;
                    this.component.arcgisReady.emit();
                }
            },
            configurable: true,
            enumerable: true,
        });
        if (currentView) {
            this._instance.view = currentView;
        }
        if (this.component.el.isConnected) {
            attachToParent(this.component);
            this._watchViewDestroy();
        }
    }
    hostDisconnected() {
        // If view is already destroyed, view.ui might be undefined
        if (typeof this.component.el.childElem === "object") {
            this.component.el.view?.ui?.remove(this.component.el.childElem);
        }
    }
    hostDestroy() {
        super.hostDestroy();
        this._watchViewDestroyHandle?.remove();
    }
    _watchMetaProperties() {
        this.watch("position", (position) => {
            if (this.component.el.childElem != null && typeof position === "string") {
                attachToParent(this.component);
            }
        });
        this.watch("referenceElement", () => attachToParent(this.component));
    }
    /**
     * Destroy the component if view gets destroyed. Note, that when view is
     * destroyed, component disconnect is triggered, which will destroy the
     * component in 1s but that can be too late, because in the meanwhile,
     * a watcher on the widget/viewModel instance may get triggered, and throw
     * an error if it's not able to access this.view.map or etc
     * (happens in VersionManagementViewModel for example).
     * We can't check for this in disconnectedCallback though as, if the entire
     * component tree is removed, the disconnect for the component will be
     * triggered before that of arcgis-map, so the view might not be destroyed
     * yet at that point.
     */
    _watchViewDestroy() {
        this._watchViewDestroyHandle?.remove();
        this._watchViewDestroyHandle = this.reactiveUtils.when(() => this.component.el.view?.destroyed === true, () => void this.component.destroy().catch(console.error), { sync: true });
    }
}
const proxy = proxyExports(ViewModelController);

const useT9n = makeT9nController(getAssetPath);

export { makeViewModelController as m, useT9n as u };
