/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.7
 */
'use strict';

const index = require('./index-8d100f9f.js');
require('./index-c3c4ddd9.js');
const componentUtils = require('./component-utils-387e34d8.js');
const chunkPVEVZB4O = require('./chunk-PVEVZB4O-270e4213.js');
const index$1 = require('./index-eee1d83b.js');

/**
 * A controller for a mapping component that:
 * - loads the viewModel
 * - initializes the viewModel with the component's properties
 * - does two-way binding between view model and component properties
 * - re-emits the viewModel's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/main/packages/map-components/src/controllers/useViewModel.md
 */
const makeViewModelController = (loadViewModel, _options) => (component, options) => proxy(component, loadViewModel, options);
// REFACTOR: extract common logic into IntegrationController???
class ViewModelController extends index.AccessorController {
    hostConnected() {
        if (this.component.manager.didLoadCalled) {
            componentUtils.attachToParent(this.component);
        }
    }
    async hostLoad() {
        await super.hostLoad();
        if (this.component.manager.destroyed) {
            return;
        }
        this._watchMetaProperties();
        index.accessorSupport.reEmitAccessorEvents(this, this._instance, this.reactiveUtils, "viewModel");
    }
    hostLoaded() {
        const { el } = this.component;
        const childNode = el.shadowRoot?.firstElementChild ?? el.firstElementChild ?? undefined;
        /*
         * On hot reloading, new this.component instance is created (so properties
         * on it are reset) but this.component.el instance is preserved (so
         * properties on it are preserved). Since childElem is re-parented on 1st
         * hostLoad(), for it to be accessible on the 2nd hostLoad() (hot reload),
         * we have to store it's reference on the el, rather than component
         */
        el.childElem = childNode ?? el.childElem;
        if (el.childElem === undefined && "production" !== "production") {
            throw new Error("Unable to find component's root child");
        }
        let arcgisReadyEmitted = false;
        // Check if view was already provided by the user
        const currentView = this.component.el.view;
        // Define the "view" property to allow component usage with MapView/SceneView
        Object.defineProperty(this.component.el, "view", {
            get: () => this._instance.view,
            set: (view) => {
                this._instance.view = view;
                this._watchViewDestroy();
                this.component.requestUpdate();
                if (!arcgisReadyEmitted) {
                    arcgisReadyEmitted = true;
                    this.component.arcgisReady.emit();
                }
            },
            configurable: true,
            enumerable: true,
        });
        if (currentView) {
            this._instance.view = currentView;
        }
        if (this.component.el.isConnected) {
            componentUtils.attachToParent(this.component);
            this._watchViewDestroy();
        }
    }
    hostDisconnected() {
        // If view is already destroyed, view.ui might be undefined
        if (typeof this.component.el.childElem === "object") {
            this.component.el.view?.ui?.remove(this.component.el.childElem);
        }
    }
    hostDestroy() {
        super.hostDestroy();
        this._watchViewDestroyHandle?.remove();
    }
    _watchMetaProperties() {
        this.watch("position", (position) => {
            if (this.component.el.childElem != null && typeof position === "string") {
                componentUtils.attachToParent(this.component);
            }
        });
        this.watch("referenceElement", () => componentUtils.attachToParent(this.component));
    }
    /**
     * Destroy the component if view gets destroyed. Note, that when view is
     * destroyed, component disconnect is triggered, which will destroy the
     * component in 1s but that can be too late, because in the meanwhile,
     * a watcher on the widget/viewModel instance may get triggered, and throw
     * an error if it's not able to access this.view.map or etc
     * (happens in VersionManagementViewModel for example).
     * We can't check for this in disconnectedCallback though as, if the entire
     * component tree is removed, the disconnect for the component will be
     * triggered before that of arcgis-map, so the view might not be destroyed
     * yet at that point.
     */
    _watchViewDestroy() {
        this._watchViewDestroyHandle?.remove();
        this._watchViewDestroyHandle = this.reactiveUtils.when(() => this.component.el.view?.destroyed === true, () => void this.component.destroy().catch(console.error), { sync: true });
    }
}
const proxy = index.proxyExports(ViewModelController);

const useT9n = chunkPVEVZB4O.makeT9nController(index$1.getAssetPath);

exports.makeViewModelController = makeViewModelController;
exports.useT9n = useT9n;
