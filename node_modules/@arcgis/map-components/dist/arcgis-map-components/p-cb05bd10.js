/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.7
 */
import{D as t,c as s,d as e,e as i,f as o,h as n,j as r,k as h,i as c}from"./p-15a5fd04.js";var a=t=>t.constructor.elementProperties,l=(63,t=>Object.entries(t.manager.internals.members??{}).filter((([t,[s]])=>!!(63&s))).map((([t])=>t))),d=(t,s)=>t.manager.internals.members?.[s]?.[0];function u(t,s){const e=d(t,s);return void 0===e?void 0:32&e?"state":"prop"}var p,f=Symbol("controller"),y=["The value you passed is not a controller and not a controller exports. If ","your controller exports a literal value, try making your controller export ","an object instead"].join(""),v=class s{constructor(e){this._callbacks={hostConnected:[],hostDisconnected:[],hostLoad:[],hostLoaded:[],hostUpdate:[],hostUpdated:[],hostDestroy:[],hostLifecycle:[]},this._ready=new t,this._lifecycleDisconnected=[],this.connectedCalled=!1,this.willLoadCalled=!1,this.didLoadCalled=!1,this[p]=!0,this.ready=this._ready.promise,this._exports=w(this),this._exportWatchers=new Set;const i=function(t){if("addController"in t)return t;throw new Error("Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line")}(e??s.internals.retrieveComponent(new.target.name));Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:i}),this.component.addController(this),s.internals.setParentController(this),"hostDestroy"in this&&this.component.manager.ensureHasDestroy(),void 0===this.component.manager||queueMicrotask((()=>this.catchUpLifecycle()))}catchUpLifecycle(){const{manager:t}=this.component;!t.connectedCalled||this.connectedCalled||this.triggerConnected(),!t.willLoadCalled||this.triggerLoad().then((()=>{!t.didLoadCalled||this.triggerLoaded()})).catch(console.error)}get exports(){return this._exports}set exports(t){this._exports!==t&&(this._exports=t,this.connectedCalled&&this.component.requestUpdate(),this._exportWatchers.forEach(e)),this._ready.resolve(t)}setProvisionalExports(t){this._exports=w(t),this._exportWatchers.forEach(e)}watchExports(t){const s=()=>t(this._exports);return this._exportWatchers.add(s),()=>{this._exportWatchers.delete(s)}}get use(){return s.internals.setAmbientComponent(this.component),s.internals.use}get useRef(){return s.internals.setAmbientComponent(this.component),s.internals.useRef}get useRefSync(){return s.internals.setAmbientComponent(this.component),s.internals.useRefSync}bypassSetter(t){s.internals.shouldBypassSetter=!0;try{return t()}finally{s.internals.shouldBypassSetter=!1}}bypassReadonly(t){s.internals.shouldBypassReadonly=!0;try{return t()}finally{s.internals.shouldBypassReadonly=!1}}bypassGetter(t){s.internals.shouldBypassGetter=!0;try{return t()}finally{s.internals.shouldBypassGetter=!1}}dynamicGetSet(t,s){this.genericGetSet(t,s)}genericGetSet(t,s){var e,i;const o=s,n=this.component.manager.internals;"function"==typeof o.get&&((e=n.getters)[t]??(e[t]=[]),n.getters[t].unshift(o.get));const r="ignore"===o.set?k:o.set;r&&((i=n.setters)[t]??(i[t]=[]),n.setters[t].unshift(r))}watch(t,s){var i;if(void 0===d(this.component,t))throw new Error(`Trying to watch a non-@property, non-@state property "${t}". Either convert it into a @state() or use get/set syntax`);const o=this.component.manager.internals;(i=o.allWatchers)[t]??(i[t]=[]);const n=o.allWatchers[t],r=s,h=(t,s,i)=>e(r,null,t,s,i);return n.push(h),()=>{const t=n.indexOf(h);-1!==t&&n.splice(t,1)}}controllerRemoved(){this.component.el.isConnected&&this.triggerDisconnected(),this.triggerDestroy()}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this.component.manager.ensureHasDestroy(),this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){const t=this;t.hostConnected&&e(t.hostConnected,t),this._callbacks.hostConnected.forEach(e),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){const t=this;t.hostDisconnected&&e(t.hostDisconnected,t),this._callbacks.hostDisconnected.forEach(e),this._lifecycleDisconnected.forEach(e),this._lifecycleDisconnected=[]}async triggerLoad(){if(this.willLoadCalled)return;this.willLoadCalled=!0;const t=this;t.hostLoad&&await i(t.hostLoad,t),this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(i)),this._ready.resolve(this._exports)}triggerLoaded(){if(this.didLoadCalled)return;const t=this;t.hostLoaded&&e(t.hostLoaded,t),this._callbacks.hostLoaded.forEach(e),this.didLoadCalled=!0}triggerUpdate(){const t=this;t.hostUpdate&&e(t.hostUpdate,t),this._callbacks.hostUpdate.forEach(e)}triggerUpdated(){const t=this;t.hostUpdated&&e(t.hostUpdated,t),this._callbacks.hostUpdated.forEach(e)}triggerDestroy(){const t=this;t.hostDestroy&&e(t.hostDestroy,t),this._callbacks.hostDestroy.forEach(e)}triggerLifecycle(){const t=this;t.hostLifecycle&&this._callLifecycle((()=>t.hostLifecycle())),this._callbacks.hostLifecycle.forEach((t=>this._callLifecycle(t)))}_callLifecycle(t){s.internals.setAmbientComponent(this.component);const i=e(t);(Array.isArray(i)?i:[i]).forEach((t=>{"function"==typeof t?this._lifecycleDisconnected.push(t):"object"==typeof t&&"function"==typeof t.remove&&this._lifecycleDisconnected.push(t.remove)}))}};p=f,v.internals=new class{constructor(){this._ambientControllers=[],this.use=async(t,s)=>{const e=this.useRefSync(t);if(void 0===e){if("function"==typeof s){const t=new Error(`Unable to resolve a controller from the provided value, so can't watch it's exports. ${y}`);console.error(t)}return t}if(await e.ready,"function"==typeof s){if(void 0===e.watchExports)throw new Error("The controller must implement watchExports method to support watching exports");const t=e.watchExports((e=>s(e,t)))}return e.exports},this.useRef=async t=>{const s=this.useRefSync(t);if(void 0===s)throw new Error(`Unable to resolve a controller from the provided value. ${y}`);return await s.ready,s},this.useRefSync=t=>{const s=this.retrieveAmbientChildController();if(void 0!==s)return s;const e=m.internals.retrieveComponent().manager.internals.resolveExports(t);return void 0!==e?e:(t=>"object"==typeof t&&null!==t&&(f in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t))(t)?t:void 0},this.shouldBypassSetter=!1,this.shouldBypassGetter=!1,this.shouldBypassReadonly=!1,this.elementToInstance=new WeakMap}setAmbientComponent(t){this._ambientComponent!==t&&(this._ambientComponent=t,queueMicrotask((()=>{this._ambientComponent===t&&(this._ambientComponent=void 0)})))}retrieveComponent(t){if(void 0===this._ambientComponent)throw new Error([`Unable to find out which component ${t||"this"} controller `,"belongs to. This might happen if you tried to create a controller ","outside the component. If so, please wrap your controller ","definition in an arrow function, ","`const myController = ()=>makeController(...);` and call that","function inside the component `my = myController();`, or ","define your controller using makeGenericController/GenericController ","instead.\n","If you wish to use a controller inside an async controller, ","make sure you are using controller.use.\n","You might also have multiple instances of Controllers loaded"].join("\n"));return this._ambientComponent}setParentController(t){if(void 0===t)return void(this._ambientControllers=[]);const s=this._ambientControllers.indexOf(t);this._ambientControllers=-1===s?[...this._ambientControllers,t]:this._ambientControllers.slice(0,s+1),queueMicrotask((()=>{this._ambientControllers=[]}))}retrieveParentControllers(){return this._ambientControllers}setAmbientChildController(t){this._ambientChildController!==t&&(this._ambientChildController=t,queueMicrotask((()=>{this._ambientChildController===t&&(this._ambientChildController=void 0)})))}retrieveAmbientChildController(){const t=this._ambientChildController;return this._ambientChildController=void 0,t}};var m=v,g=class extends m{constructor(t){super(t)}watch(t,s){return super.watch(t,s)}dynamicGetSet(t,s){super.genericGetSet(t,s)}};function w(t){if("object"!=typeof t&&"function"!=typeof t||null===t)return t;const s=new Proxy(t,{get(t,e,i){if(!b.has(e)||!(e in t)||t[e]!==s)return e in t||e in Promise.prototype||"symbol"==typeof e?"function"==typeof t?t[e]:Reflect.get(t,e,i):void console.error(`Trying to access "${e.toString()}" on the controller before it's loaded. ${C}`)},set:(t,s,e,i)=>(console.error(`Trying to set "${s.toString()}" on the controller before it's loaded. ${C}`),Reflect.set(t,s,e,i))});return s}var b=new Set(["exports","_exports"]),C="",k=(t,s)=>s;function x(t,s,i){const o=Object.keys(t),n=o.length;void 0===D&&queueMicrotask(j),D??(D=new Map);let r=D.get(t);return void 0===r&&(r={callbacks:[],keyCount:n},D.set(t,r)),r.keyCount!==n&&(r.callbacks.forEach((t=>t(o))),r.callbacks=[],r.keyCount=n),r.callbacks.push((o=>{const r=o[n];e(s,null,void 0===r?void 0:t[r]===i?r:void 0)})),i}var D=void 0;function j(){Array.from(D?.entries()??[]).forEach((([t,{callbacks:s}])=>{const e=Object.keys(t);s.forEach((t=>t(e)))})),D=void 0}var S=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.trackKey=(t,s,e)=>{const i=Array.isArray(t)?t:[t];let o=i.length+1;const n=t=>{o-=1,void 0!==t&&(o=0),0===o&&s(t)};return i.forEach((t=>this.component.manager.trackPropertyKey(t,(s=>n(void 0===s?void 0:{key:s,host:t,type:"property",domValue:void 0})),e))),this.component.manager.trackPropKey(((t,s)=>{const e=void 0===t?void 0:u(this.component,t);n(void 0===t?void 0:{key:t,host:this.component,type:e??"prop",domValue:"prop"===e?s:void 0})}),e),e},this.trackPropKey=(t,s)=>(this._trackedValue!==P&&this._trackedValue!==s&&this._firePropertyTrackers(void 0,void 0,void 0),0===this._keyTrackers.length&&queueMicrotask((()=>this._firePropertyTrackers(void 0,void 0,void 0))),this._trackedValue=s,this._keyTrackers.push(((i,o,n)=>e(t,void 0,s===o?i:void 0,n))),s),this._trackedValue=P,this._keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this.reactiveUtilsIntegrations=new Set,this._exports=new WeakMap,Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:t})}_firePropertyTrackers(t,s,e){const i=this._keyTrackers;this._trackedValue=P,this._keyTrackers=[],i.forEach((i=>i(t,s,e)))}getSetProxy(t,s,e){const i=this.component,o=i.constructor.prototype;if(this._getSetProxy(o,t,s,e,"class"),i.manager.isLit)return;const n=i.el.constructor.prototype;o!==n&&this._getSetProxy(n,t,s,e,"html")}_getSetProxy(t,s,e,i,o){const n=this.component,r=d(n,s),h=Object.getOwnPropertyDescriptor(t,s),c="html"===o;if(void 0===h?.set||void 0===h.get){if(void 0!==h&&"value"in h)throw new Error(`getSet() should only be used on @Prop/@property/@State/@state properties. For internal component properties, use regular get/set syntax. Tried to use it on "${s}" in ${n.el.tagName}`);if(c)return;throw new Error(`Unable to find "${s}" property on the ${n.el.tagName} component`)}const{get:a,set:l}=h,u=!(E in a)&&e,p=!(E in l)&&i;if(!u&&!p)return;const f=u?function(){let t=a.call(this);const e=m.internals.elementToInstance.get(this);if(m.internals.shouldBypassGetter||void 0===e)return t;const i=e.manager.internals;t=i.accessorGetter[s](t,s);const o=i.getters[s]??U;for(let e=0;e<o.length;e++)t=o[e](t,s);return t}:a,y=p?function(t){const e=a.call(this),i=m.internals.elementToInstance.get(this);if(void 0===i)return void l.call(this,t);let o=i.manager.isLit?t:function(t,s=8){return null==t||"object"==typeof t||"function"==typeof t?t:4&s?"false"!==t&&(""===t||!!t):2&s?Number.parseFloat(t):1&s?String(t):t}(t,r);const n=i.manager.internals;if(o===e)l.call(this,t);else{const t=m.internals.shouldBypassSetter?U:n.setters[s]??U;for(let i=0;i<t.length&&(o=t[i](o,e,s),o!==e);i++);o=n.accessorSetter[s](o,e,s),l.call(this,o),o!==e&&n.enabledWatchers[s]?.forEach((t=>t(o,e,s)))}n._keyTrackers.length>0&&n?._firePropertyTrackers(s,t,e)}:l;u&&Object.defineProperty(f,E,{value:!0}),p&&Object.defineProperty(y,E,{value:!0}),Object.defineProperty(t,s,{...h,get:f,set:y})}markExports(t,s){("object"==typeof s&&null!==s||"function"==typeof s)&&this._exports.set(s,t)}resolveExports(t){return"object"==typeof t&&null!==t||"function"==typeof t?this._exports.get(t):void 0}},U=[],E=Symbol("controllersCustomAccessor"),P=Symbol("nothing"),L=(t,s)=>new A(t,s),A=class extends g{constructor(e,i){const o="addController"in e,n=new Set,r=e;if(r.addController=function(t){n.add(t),o&&!(f in t)&&e.el.isConnected&&t.hostConnected?.()},r.removeController=function(t){n.delete(t),t.controllerRemoved?.()},!o){const t=i??e.constructor.__forceUpdate;r.requestUpdate=()=>t(e)}super(e),this.internals=new S(this.component),this.destroyed=!1,this._updatePromise=new t,this._originalLifecycles={},this.trackPropertyKey=x,this.trackPropKey=this.internals.trackPropKey,this.trackKey=this.internals.trackKey,this._readonlySetter=(t,e,i)=>{if(m.internals.shouldBypassReadonly)return t;const o=this.component;if("prop"===u(o,i))if(this.isLit){const t=a(o).get(i);t&&!1!==t?.attribute&&o.el.setAttribute("string"==typeof t.attribute?t.attribute:s(i),String(e))}else o.requestUpdate();throw new Error(`Cannot assign to read-only property "${i}" of ${o.el.tagName.toLowerCase()}. Trying to assign "${String(t)}"`)},this.devOnlySetPersistentControllerData=void 0,this.devOnlyGetPersistentControllerData=void 0,this.isLit=o,this.component.manager=this,function(t,s){if(s){const s=a(t);t.manager.internals.members=Object.fromEntries(Array.from(s,(([t,{state:s,type:e}])=>[t,[s?32:e===Number?2:e===Boolean?4:1]])))}else{const s=t.constructor,e=s.__registerControllers?.(t)??void 0;if(s.__registerControllers=void 0,"object"!=typeof e)throw new Error("Failed to retrieve internal component meta. Make sure you have the useComponentsControllers() Rollup Plugin for Stencil Controllers configured in your Stencil config.");t.manager.internals.members=e}}(e,o),this._controllers=n,this.exports=void 0,this.hasDestroy="autoDestroyDisabled"in this.component&&"function"==typeof this.component.destroy,this.hasDestroy&&this.watch("autoDestroyDisabled",(()=>this._autoDestroyDisabledWatcher())),this._bindLifecycleMethods(),o||Object.defineProperty(e,"updateComplete",{get:async()=>await this._updatePromise.promise});const h=l(e),c=e.manager.internals;h.forEach((t=>{c.accessorGetter[t]=O,c.accessorSetter[t]=O,c.getSetProxy(t,!0,!0)})),m.internals.setParentController(void 0),m.internals.setAmbientComponent(e),m.internals.elementToInstance.set(e.el,e),m.internals.elementToInstance.set(e,e)}_bindLifecycleMethods(){const t=this.component,s=this.isLit,e=t.el===t;this._originalLifecycles={connectedCallback:s||e?void 0:t.connectedCallback,disconnectedCallback:s||e?void 0:t.disconnectedCallback,componentWillLoad:s?void 0:t.componentWillLoad,componentDidLoad:s?void 0:t.componentDidLoad,componentWillUpdate:s?void 0:t.componentWillUpdate,componentDidUpdate:s?void 0:t.componentDidUpdate,destroy:t.destroy};const i=this._connectedCallback.bind(this),o=this._disconnectedCallback.bind(this),n=this._update.bind(this),r=this._updated.bind(this);s?t.constructor.prototype.addController.call(t,{hostConnected:i,hostDisconnected:o,hostUpdate:n,hostUpdated:r}):(t.connectedCallback=i,t.disconnectedCallback=o,t.componentWillLoad=this._load.bind(this),t.componentDidLoad=this._loaded.bind(this),t.componentWillUpdate=n,t.componentDidUpdate=r),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}ensureHasDestroy(){if(!this.hasDestroy)throw new Error($)}_connectedCallback(){if(this.destroyed){const t=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${t} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the autoDestroyDisabled prop.`)}void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout),this.internals.enabledWatchers=this.internals.allWatchers,j(),this._controllers.forEach((t=>"triggerConnected"in t?t.triggerConnected():e(t.hostConnected,t))),this._originalLifecycles.connectedCallback?.call(this.component)}_disconnectedCallback(){this.destroyed||(this._controllers.forEach((t=>"triggerDisconnected"in t?t.triggerDisconnected():e(t.hostDisconnected,t))),this._originalLifecycles.disconnectedCallback?.call(this.component),this.hasDestroy&&this._autoDestroyDisabledWatcher())}async _load(){const t=this.internals.reactiveUtilsIntegrations;if(t.size>0)for(const s of t)"triggerLoad"in s?await s.triggerLoad():await i(s.hostLoad,s);await Promise.allSettled(Array.from(this._controllers,(async s=>t.has(s)?void 0:"triggerLoad"in s?await s.triggerLoad():await i(s.hostLoad,s)))),await(this._originalLifecycles.componentWillLoad?.call(this.component))}_loaded(){this._controllers.forEach((t=>"triggerLoaded"in t?t.triggerLoaded():e(t.hostLoaded,t))),this._originalLifecycles.componentDidLoad?.call(this.component)}_update(){this._controllers.forEach((t=>"triggerUpdate"in t?t.triggerUpdate():e(t.hostUpdate,t))),this._originalLifecycles.componentWillUpdate?.call(this.component)}_updated(){if(this._controllers.forEach((t=>"triggerUpdated"in t?t.triggerUpdated():e(t.hostUpdated,t))),this._originalLifecycles.componentDidUpdate?.call(this.component),!this.isLit){const s=this._updatePromise;this._updatePromise=new t,s.resolve(!0)}}async destroy(){if(this.ensureHasDestroy(),!this.destroyed){if(this.component.el.isConnected){this.hasDestroy=!1;try{this.component.el.remove()}finally{this.hasDestroy=!0}}this._autoDestroyTimeout=void 0,this.destroyed=!0,this._controllers.forEach((t=>"triggerDestroy"in t?t.triggerDestroy():e(t.hostDestroy,t))),this._controllers.clear(),await(this._originalLifecycles.destroy?.call(this.component))}}_autoDestroyDisabledWatcher(){this.component.el.isConnected||this.component.autoDestroyDisabled||(void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout),this._autoDestroyTimeout=o((()=>{this.destroy().catch(console.error)}),M))}readonly(t){return this.getSet(t,{set:this._readonlySetter})}getSet(t,s){return this.component.manager.trackPropKey((e=>{var i;if(void 0===e)throw new Error("Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = this.manager.getSet(defaultValue,{get,set})");s.set===this._readonlySetter&&((i=this.internals).readonlyProps??(i.readonlyProps=new Set),this.internals.readonlyProps.add(e));const o=this.component,n=o[e];if(null!=n&&n!==t&&"function"==typeof s.set&&(s.initialSet??1)){const i=s.set(n,t,e);if(i!==n)if(this.isLit)o[e]=i;else{let t=!0;this.onConnected((()=>{t&&(t=!0,this.bypassSetter((()=>{o[e]=i})))}))}}this.genericGetSet(e,s)}),t)}},$="\nIf the component uses a controller that uses destroy() method, then the\ncomponent must have the following properties:\nautoDestroyDisabled and destroy\n".trim(),M=1e3,O=t=>t,_=t=>(...s)=>{const e=m.internals.retrieveParentControllers(),i=new t(...s),o=i.exports;m.internals.setParentController(e.at(-1));const n=i.component.manager.internals;n.markExports(i,o),i.watchExports((t=>n.markExports(i,t))),m.internals.setAmbientChildController(i);const r=[i.component,...e].reverse();return n.trackKey(r,(t=>void 0===t?void 0:function(t,{host:s,key:e,type:i},o){const n=s,r=n[e]!==o;if(n[e]!==t.exports&&!r&&o!==t.exports&&(n[e]=t.exports),s===t.component&&"prop"===i){const s=t.component.manager.internals;r&&s.markExports(t,n[e]),t.component.manager.watch(e,(e=>{e!==t.exports&&s.markExports(t,e)}))}t.watchExports((()=>{if(n[e]===t.exports)return;const s=t.component.manager;!0===s.internals.readonlyProps?.has(e)?s.bypassReadonly((()=>{n[e]=t.exports})):n[e]=t.exports}))}(i,t,o)),o)},T=t=>R(void 0,t),R=_(class extends m{constructor(t,s){super(t);const e=this.exports;try{m.internals.setAmbientComponent(this.component);const t=s(this.component,this),i=this.exports!==e;if(t instanceof Promise){i||this.setProvisionalExports(t);const s=t.then((t=>{this.exports=t,super.catchUpLifecycle()})).catch((t=>{this._ready.reject(t),console.error(t)}));this.onLoad((async()=>await s))}else i&&void 0===t||(this.exports=t),queueMicrotask((()=>super.catchUpLifecycle()))}catch(t){this._ready.reject(t),console.error(t)}}catchUpLifecycle(){}}),q=t=>(s,e)=>I(s,t,e),G=class extends g{constructor(t,s,e){super(t),this._loadAccessor=s,this._options=e,this.reactiveUtils=this.component.reactiveUtils,this._watchedProperties=new Map,this._isBinding={value:!0},this.setProvisionalExports(W.makeGetterProxy(t,this._watchedProperties,this._isBinding,this.constructor.allowedPropNameMismatches));const i=t.manager.internals.reactiveUtilsIntegrations;i.add(this);const o=Array.from(i).find((t=>t instanceof F));o&&i.delete(o),i.add(o??new F(this.component)),t.manager.trackPropKey((t=>{t&&(this._instancePropName=t)}),this.exports)}hostConnected(){this._isBinding.value=!1}async hostLoad(){const t=this.component;this.reactiveUtils=void 0===t.reactiveUtils?await c():await this.use(t.reactiveUtils);const s=W.gatherParameters(this,this._watchedProperties),e=this._options?.editConstructorProperties?.call(t,s)??s,i=e instanceof Promise?await e:e,o="string"==typeof this._instancePropName?t[this._instancePropName]:void 0;null!=o&&o!==this.exports?(this._instance=o,o.set(i)):this._instance=await this._createInstance(i),t.manager.destroyed||(W.watchComponentUpdates(this,this._instance,this._watchedProperties),W.watchAccessorUpdates(this,this._instance,this._watchedProperties),this.exports=this._instance)}async _createInstance(t){return this._isAccessorConstructor(this._loadAccessor)?new this._loadAccessor(t):await this._loadAccessor(t)}_isAccessorConstructor(t){return"prototype"in t&&"declaredClass"in t.prototype}hostDestroy(){this._instance&&this._instance.destroy()}async reCreate(){this.hostDestroy(),await this.hostLoad()}},I=_(G),W={makeGetterProxy:(t,s,e)=>new Proxy({},{has:(t,s)=>"string"==typeof s||s in t,get:(i,o)=>{const n=Reflect.get(i,o);return"symbol"==typeof o||o in Promise.prototype||o in i||!(e?.value??1)?n:t.manager.trackKey(t,(t=>{void 0!==t&&s.set(t.key,o)}),n)}}),watchComponentUpdates(t,s,e){function i(t,i){const o=e.get(i),n=s[o];return"boolean"==typeof n&&o!==i&&i.toLowerCase().includes("disable")?!n:n}const o=(t,i,o)=>{const n=e.get(o),r=s[n],h="boolean"==typeof r&&n!==o&&o.toLowerCase().includes("disable");if((h?!r:r)===t)return t;s[n]=h?!t:t;const c=s[n];return h?!c:c},n=t.component.manager.internals;e.forEach(((t,s)=>{n.accessorGetter[s]=i,n.accessorSetter[s]=o}))},watchAccessorUpdates(t,s,e){const{component:i}=t,o=i,n=s,r=function(t){const s=t,e=Object.entries(s.__accessor__?.metadata??{});return new Set(e.filter((([t,s])=>!0===s?.readOnly)).map((([t])=>t)))}(s);i.manager.bypassGetter((()=>e.forEach(((t,s)=>{if(r.has(t))return;const e=o[s],i=n[t],h="boolean"==typeof e&&t!==s&&s.toLowerCase().includes("disable")?!e:e;null!=h&&i!==h&&(n[t]=h)})))),t.onLifecycle((()=>{if(!s.destroyed)return Array.from(e,(([s,e])=>t.reactiveUtils.watch((()=>n[e]),(()=>{const t=n[e],r="boolean"==typeof t&&e!==s&&s.toLowerCase().includes("disable")?!t:t;i.manager.bypassSetter((()=>{o[s]=r}))}),{initial:!0})))}))},gatherParameters(t,s){const{component:e}=t;return Object.fromEntries(Array.from(s,(([t,s])=>[s,e[t]])).filter((([,t])=>void 0!==t)))},reEmitAccessorEvents(t,e,i,o){if(!("on"in e)||"function"!=typeof e.on)return;const n=Object.entries(t.component).map((([t,e])=>{const i=e;if(!t.startsWith(o)||t===o||"object"!=typeof i||null===i||!("emit"in i)||"function"!=typeof i.emit)return;const n=i.emit,r=t.slice(o.length);return[s(r).toLowerCase(),n]})).filter(h);if(0===n.length)return;const r=e,c=()=>r;t.onLifecycle((()=>{if(!e.destroyed)return n.map((([t,s])=>i.on(c,t,s)))}))},async reCreate(t,s){const e=s.manager.useRefSync(t);void 0!==e&&await e.reCreate()}},V=Promise.all([n(),r()]),F=class extends g{async hostLoad(){const[t,{subclass:s,property:e}]=await V;class i extends t{}const o=(t,s)=>d[s];function n(t,s,e){return void 0!==d&&(d[e]=t),t}const r=this.component,h=r.manager.internals,c=[],a=l(this.component);if(r.manager.bypassGetter((()=>a.forEach((t=>{h.accessorSetter[t]!==O||(c.push(t),h.accessorGetter[t]=o,h.accessorSetter[t]=n,e({value:r[t]})(i.prototype,t))})))),this._enabledMembers=c,0===c.length)return;const d=new(s(r.el.tagName)(i));this._instance=d}controllerRemoved(){super.controllerRemoved();const t=this.component.manager.internals;this._instance?.destroy(),this._enabledMembers?.forEach((s=>{t.accessorGetter[s]=O,t.accessorSetter[s]=O}))}};export{G as A,W as a,T as b,q as m,_ as p,L as u}