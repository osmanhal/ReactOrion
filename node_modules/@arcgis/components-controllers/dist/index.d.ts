import { B as BaseComponent, C as ControllerHost, a as Controller, S as SafeComponentInterface, b as ControllerManager, G as GenericController, c as ControllerLifecycleMethods } from './Controller-BX9TuK8v.js';
export { e as BaseController, U as Use, d as controllerSymbol, u as useControllerManager } from './Controller-BX9TuK8v.js';
import { IHandle, T9NStrings } from '@arcgis/components-utils';
import { EventEmitter } from '@stencil/core';
import '@stencil/core/internal';
import 'lit';

/**
 * Controller is a function that takes a component instance and then can
 * export some values to the component, or hook into component's lifecycle
 *
 * See controllers documentation for many example controllers and their usages
 */
declare const makeController: <Exports>(constructor: (component: BaseComponent & ControllerHost, controller: Controller<Exports>) => Exports | Promise<Exports>) => Exports;
/**
 * If your controller requires some specific properties to be present on the
 * component, besides what's included in the BaseComponent, use
 * makeGenericController
 *
 * When using a controller created using makeGenericController(), consumer must
 * pass in "this" explicitly for proper type-checking. If controller was
 * created using makeController(), that is not necessary
 */
declare const makeGenericController: <Exports, Component = BaseComponent>(constructor: (component: SafeComponentInterface & {
    manager: ControllerManager<BaseComponent>;
    el: HTMLElement;
    autoDestroyDisabled?: boolean | undefined;
    destroy?: (() => Promise<void>) | undefined;
} & Component & ControllerHost, controller: GenericController<Exports, Component>) => Exports | Promise<Exports>) => (component: SafeComponentInterface & {
    manager: ControllerManager<BaseComponent>;
    el: HTMLElement;
    autoDestroyDisabled?: boolean | undefined;
    destroy?: (() => Promise<void>) | undefined;
} & Component) => Exports;

/**
 * Load a value from a promise and provide it to the component
 *
 * @example
 * reactiveUtils = load(importCoreReactiveUtils);
 *
 * componentWillLoad() {
 *   this.reactiveUtils.when(...)
 * }
 */
declare const load: <T>(loader: () => Promise<T>) => T;

/**
 * If you wish to directly expose the "exports" property of your controller,
 * rather than the entire controller class, wrap your class definition in
 * "proxyExports".
 *
 * This is especially convenient when your exports is not an object, or it is a
 * dynamically created object, and so you don't want your Controller's methods
 * interfering with the keys on the exported value.
 *
 * "proxyExports" is the default behavior for all controllers declared using
 * the makeController()/makeGenericController() function
 *
 * @remarks
 * If using this.manager.readonly(), and controller updates it's exports, the
 * readonly prop will still get updated.
 *
 * @remarks
 * (Advanced) If you wish to use proxyExports() in a class that does not
 * extend Controller class and does not have a useControllerManager(), then your
 * class must subclass a class with the following constructor:
 * `constructor() { Controller.internals.setAmbientController(this); }`. This
 * is necessary for proxyExports() to receive a reference to your object
 * implicitly, and before any of your default values are assigned.
 */
declare const proxyExports: <Exports, const Parameters_1 extends unknown[]>(Class: new (...args: Parameters_1) => ControllerLifecycleMethods & Pick<Controller<Exports>, "component" | "exports" | "watchExports">) => (...args: Parameters_1) => Exports;

/**
 * Code that tightly integrates with Stencil's or Lit's internals is isolated to
 * this single file to minimize the spread of the possible breakages on framework
 * version update
 *
 * In case of Stencil, since we are using the ComponentRuntimeMeta type from
 * Stencil, changes on the Stencil's side would likely trigger a TypeScript
 * error first.
 * In case of Lit, we are accessing only a single private property.
 *
 * Also, we have comprehensive tests for Controllers.
 */

/**
 * Get names of all @Prop() members on the component
 */
declare const getPropMembers: (component: BaseComponent) => readonly string[];
/**
 * Get names of all @State()/@Prop() members on the component
 */
declare const getPropLikeMembers: (component: BaseComponent) => readonly string[];
declare function getPropType(component: BaseComponent, name: string): "prop" | "state" | undefined;

/**
 * A tiny helper for using a class-based controller as if it's a function.
 * Main advantage of this is that it's a bit shorter to type.
 *
 * This utility can be used for converting non-controller classes to functions
 * too
 */
declare const toFunction: <T, const P extends unknown[]>(Class: new (...args: P) => T) => (...args: P) => T;

/**
 * Based on handle management in Accessor in JS API
 */

/**
 * Avoid accidentally adding objects that look like handles because they have a `remove` method,
 * but are not because they can be destroyed e.g. the Handles object.
 */
type SafeHandle = IHandle & {
    destroy?: null;
};
/**
 * Avoid accidentally using a handle as a group key.
 */
type GroupKey<T> = Exclude<T, IHandle>;
declare class HandleManager extends Controller {
    destroyed: boolean;
    private _handles;
    constructor(removeOn: "destroy" | "disconnect");
    /**
     * Adds one or more handles which are to be tied to the lifecycle of the object. The handles will
     * be removed when the object is destroyed.
     *
     * ```js
     * // Manually manage handles
     * const handle = reactiveUtils.when(
     *   () => !view.updating,
     *   () => {
     *     wkidSelect.disabled = false;
     *   },
     *   { once: true }
     * );
     *
     * this.addHandles(handle);
     *
     * // Destroy the object
     * this.destroy();
     * ```
     * @method addHandles
     * @since 4.25
     * @instance
     * @param {module:esri/core/Accessor~WatchHandle | module:esri/core/Accessor~WatchHandle[]} handleOrHandles
     *    Handles marked for removal once the object is destroyed.
     * @param {*} [groupKey]
     *    Key identifying the group to which the handles should be added. All the handles in the group
     *    can later be removed with {@link module:esri/core/Accessor#removeHandles Accessor.removeHandles()}.
     *    If no key is provided the handles are added to a default group.
     */
    addHandles<T>(handleOrHandles: SafeHandle | SafeHandle[], groupKey?: GroupKey<T>): void;
    /**
     * Removes a group of handles owned by the object.
     *
     * @method removeHandles
     * @since 4.25
     * @instance
     *
     * @param {*} [groupKey] - A group key or an array or collection of group keys to remove.
     *
     * @example
     * obj.removeHandles(); // removes handles from default group
     *
     * obj.removeHandles("handle-group");
     * obj.removeHandles("other-handle-group");
     */
    removeHandles<T>(groupKey?: GroupKey<T>): void;
    /**
     * Removes all the handles currently associated with the object.
     *
     * @ignore
     */
    removeAllHandles(): void;
    destroy(): void;
    /**
     * Returns true if a named group of handles exist.
     *
     * @method hasHandles
     * @since 4.25
     * @instance
     * @param {*} [groupKey] - A group key.
     * @return {boolean} Returns `true` if a named group of handles exist.
     *
     * @example
     * // Remove a named group of handles if they exist.
     * if (obj.hasHandles("watch-view-updates")) {
     *   obj.removeHandles("watch-view-updates");
     * }
     */
    hasHandles<T>(groupKey?: GroupKey<T>): boolean;
}
/**
 * Note: you might not need useHandles. See manager.onLifecycle instead.
 *
 * useHandles() implements the following methods from JS API's Accessor class:
 * addHandles - https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#addHandles
 * hasHandles - https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#hasHandles
 * removeHandles - https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#removeHandles
 * removeAllHandles - (hidden from the JS API's JS Doc)
 *
 * Except, to adapt these to web-components, you have an option of picking
 * whether handles should get removed on component disconnect or destroy.
 *
 * destroy() is an opt-in lifecycle event provided by the controllers API.
 * Read controllers documentation for instructions on how to opt it.
 *
 * Prefer using "disconnect" over "destroy" when possible
 */
declare const useHandles: (removeOn: "destroy" | "disconnect") => HandleManager;

type Meta = {
    _lang: string;
    _t9nLocale: string;
};
type Options = {
    readonly name?: string;
};
/**
 * Load component's localization strings.
 *
 * Note, to use correct asset path in each package using controllers, you need
 * to create a `useT9n` controller using the `makeT9nController` factory
 * function.
 *
 * @example
 * // Creating a `useT9n` controller
 * import { makeT9nController } from "@arcgis/components-controllers";
 * import { getAssetPath } from "@stencil/core";
 * const useT9n = makeT9nController(getAssetPath);
 *
 * @example
 * @Component({ tag: "arcgis-home", assetsDirs: ["assets"] })
 * export class Home {
 *   messages = useT9n<HomeStrings>();
 * }
 *
 * @remarks
 * When using this controller, `@State()` is not needed as Controller will
 * trigger the update automatically when necessary.
 *
 * The strings are loaded async and might not be available by the time your
 * component renders. If you wish to delay render() until the strings are ready,
 * pass `true` as the first argument to `useT9n`.
 */
interface UseT9n {
    <Strings extends T9NStrings>(options: Options & {
        readonly blocking: true;
    }): Meta & Strings;
    <Strings extends T9NStrings>(options?: Options & {
        readonly blocking?: false;
    }): Meta & Partial<Strings>;
}
declare const makeT9nController: (getAssetPath: (path: string) => string) => UseT9n;

/**
 * Like Stencil's EventEmitter, but with disabled covariance check
 */
type CovariantEventEmitter<T> = {
    emit(data?: T): ReturnType<EventEmitter<T>["emit"]>;
};
/**
 * While we don't actually return CustomEvent<T>, claiming that we do simplifies
 * typing.
 *
 * See:
 * ```ts
 * handleClick(event: ArcgisCounter['arcgisClick']): void {
 * }
 * ```
 *
 * Without it, you would have to do:
 * ```ts
 * handleClick(event: ReturnType<ArcgisCounter['arcgisClick']['emit']>): void {
 * }
 * ```
 *
 * This is also used by @esri/lit to more easily find all event properties
 */
type PropertyChangeController<Component extends BaseComponent> = <ToWatch extends keyof Component>(...toWatch: ToWatch[]) => CovariantEventEmitter<{
    name: ToWatch & string;
}> & CustomEvent<{
    name: ToWatch & string;
}>;
/**
 * Let user easily set watchers for component properties.
 * Unlike reactiveUtils, these watchers can be set from JSX.
 *
 * See example 10 in ./3.stencil.md for more documentation:
 * https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/main/packages/support-packages/components-controllers/docs/3.stencil.tsx
 *
 * @example
 * // Using usePropertyChange in your component:
 * @Event({ cancelable:true }) arcgisPropertyChange = usePropertyChange<this>()('prop1', 'prop2');
 *
 * @example
 * // Using a component that has arcgisPropertyChange event:
 * // in JSX:
 * <ArcgisCompass
 *   onarcgisPropertyChange={({detail, target}) =>
 *     console.log(detail.name, target[detail.name])
 *   }
 * />
 *
 * // natively:
 * const compass = document.createElement("arcgis-compass");
 * compass.addEventListener("arcgisPropertyChange", ({detail, target}) => {
 *  console.log(detail.name, target[detail.name]);
 * });
 */
declare const usePropertyChange: <Component extends BaseComponent>(_component?: BaseComponent) => PropertyChangeController<Component>;

declare const isController: (value: unknown) => value is ControllerLifecycleMethods;
/**
 * This function uses a Promise to implement a simple first-in, first-out queue
 * of functions to be called.
 *
 * The queue is ordered on the basis of the first argument. If it's
 * `undefined`, then nothing is on the queue yet, so the provided function can
 * be called synchronously (although note that this function may return a
 * `Promise`). The idea is that then the return value of that enqueueing
 * operation is kept around, so that if it was a `Promise` then subsequent
 * functions can be enqueued by calling this function again with that `Promise`
 * as the first argument.
 *
 * @param maybePromise either a `Promise` which should resolve before the next function is called or an 'empty' sentinel
 * @param fn a function to enqueue
 * @returns either a `Promise` or the return value of the provided function
 * @example
 * let promise: Promise<void> | undefined;
 * promise = enqueue(promise,()=>component.load());
 * promise = enqueue(promise,()=>component.loaded());
 * if(promise === undefined)
 *   return;
 * else {
 *   await promise;
 * }
 */
declare const enqueue: (maybePromise: Promise<void> | undefined, callback: () => Promise<void> | undefined) => Promise<void> | undefined;

export { BaseComponent, Controller, ControllerHost, ControllerLifecycleMethods, ControllerManager, type CovariantEventEmitter, GenericController, type GroupKey, SafeComponentInterface, type SafeHandle, type UseT9n, enqueue, getPropLikeMembers, getPropMembers, getPropType, isController, load, makeController, makeGenericController, makeT9nController, proxyExports, toFunction, useHandles, usePropertyChange };
