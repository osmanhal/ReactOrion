import {
  toFunction
} from "../chunk-PVEVZB4O.js";
import {
  Controller,
  useControllerManager
} from "../chunk-2CDDVOQU.js";
import "../chunk-O63SSNBH.js";
import {
  __decorateClass
} from "../chunk-3KNDPG6Y.js";

// src/testing/testingUtils.ts
import { newSpecPage } from "@stencil/core/testing";
import { Component, Element, forceUpdate } from "@stencil/core";
async function spec(component, opts) {
  const additionalComponents = opts?.components ?? [];
  const page = await newSpecPage({
    html: resolveDefaultHtml(component),
    ...opts,
    components: Array.from(/* @__PURE__ */ new Set([...additionalComponents, component]))
  });
  const fullerPage = page;
  if (page.root === void 0) {
    throw new Error("Root component is not found");
  }
  fullerPage.el = page.root;
  fullerPage.component = page.rootInstance;
  return fullerPage;
}
async function multiSpec(component, {
  html,
  count,
  ...rest
} = {}) {
  const defaultHtml = resolveDefaultHtml(component);
  const template = Array.isArray(html) ? html : [html || defaultHtml];
  const resolvedHtml = Array.from(
    { length: count ?? (template.length === 1 ? 2 : 1) },
    (_, index) => typeof template[0] === "function" ? template[0](index) : template
  ).flat();
  const additionalComponents = rest?.components ?? [];
  const page = await newSpecPage({
    html: resolvedHtml.join("\n"),
    ...rest,
    components: Array.from(/* @__PURE__ */ new Set([...additionalComponents, component]))
  });
  const fullerPage = page;
  if (page.root === void 0) {
    throw new Error("Root component is not found");
  }
  fullerPage.el = page.root;
  fullerPage.component = page.rootInstance;
  fullerPage.els = Array.from(page.body.querySelectorAll("te-st"), (el) => el);
  fullerPage.components = fullerPage.els.map(
    (el) => Controller.internals.elementToInstance.get(el)
  );
  return fullerPage;
}
function resolveDefaultHtml(component) {
  if (!("COMPILER_META" in component)) {
    throw new Error(
      "Component is missing compiler metadata. Possibly because Stencil version was updated and this util needs to be updated."
    );
  }
  const tagName = component.COMPILER_META.tagName;
  return `<${tagName}></${tagName}>`;
}
function wrapController(controller, afterConstruct) {
  let Test = class {
    constructor() {
      this.manager = useControllerManager(this, forceUpdate);
      const controllerFunction = "prototype" in controller ? toFunction(controller) : controller;
      this.controller = controllerFunction(this.manager.component);
      void Promise.resolve(afterConstruct?.(this)).catch(console.error);
    }
    /*
     * Emitting controller's exports here is useful to let controller tests
     * verify that re-render was triggered when necessary
     */
    render() {
      return String(
        typeof this.controller === "object" && this.controller !== null && "exports" in this.controller ? this.controller.exports : this.controller
      );
    }
  };
  __decorateClass([
    Element()
  ], Test.prototype, "el", 2);
  Test = __decorateClass([
    Component({ tag: "te-st" })
  ], Test);
  return Test;
}
export {
  multiSpec,
  spec,
  wrapController
};
