import { B as BaseComponent, C as ControllerHost } from '../Controller-BX9TuK8v.js';
import { NewSpecPageOptions, SpecPage } from '@stencil/core/internal';
import '@arcgis/components-utils';
import '@stencil/core';
import 'lit';

type FullerPage<Component extends BaseComponent> = SpecPage & {
    /**
     * "el" won't contain any states, watchers, or internal properties (only props
     * and methods), unless you are in a custom elements build, in which case this
     * is equal to component
     */
    el: HTMLElement & Omit<Component, "manager">;
    component: Component & ControllerHost;
};
/**
 * A wrapper for `newSpecPage` that improves typing when testing components that
 * use controllers by adding `el` and `component` properties (better typed
 * versions of existing `root` and `rootInstance`)
 *
 * `spec` also reduces the need for explicitly passing the HTML string as it
 * uses the following by default:
 * `<your-component-tag-name></your-component-tag-name>`
 */
declare function spec<Component extends BaseComponent>(component: new () => Component, 
/**
 * You are not required to provide an html string, if the default one works
 * for you:
 * <your-component-tag-name></your-component-tag-name>
 */
opts?: Partial<NewSpecPageOptions>): Promise<FullerPage<Component>>;
type MultiPage<Component extends BaseComponent> = FullerPage<Component> & {
    els: FullerPage<Component>["el"][];
    components: FullerPage<Component>["component"][];
};
/**
 * A wrapper for `spec` that makes it easy to create multiple instances of a
 * component at once to make sure they don't interfere with each other.
 *
 * @remarks
 * Calling `newSpecPage` multiple times cleans up after the previous call,
 * making component from the previous `newSpecPage` call unusable, thus
 * `multiSpec` is necessary.
 *
 * @example
 * // Create two instances
 * const {
 *   els: [el1, el2],
 *   components: [component1, component2]
 * } = await multiSpec(
 *   Test,
 *   { html: ['<te-st name="test1" />', '<te-st name="test2" />'] }
 * );
 *
 * @example
 * // Make 5 instances like <te-st />
 * const { els, components } = await multiSpec(Test, { count: 5 } );
 *
 * @example
 * // Make 5 instances with different templates
 * const { els, components } = await multiSpec(Test, {
 *   count: 5,
 *   html: (index)=>`<te-st prop="${index}" />`
 * } );
 */
declare function multiSpec<Component extends BaseComponent>(component: new () => Component, 
/**
 * You are not required to provide html string, if the default one works for
 * you:
 * <your-component-tag-name></your-component-tag-name>
 */
{ html, count, ...rest }?: Omit<Partial<NewSpecPageOptions>, "html"> & {
    readonly html?: string[] | string | ((index: number) => string);
    readonly count?: number;
}): Promise<MultiPage<Component>>;
/**
 * Wrap a controller in a small component - useful when you are interested in
 * only testing the controller behavior.
 *
 * @example
 * const testController = (): string => makeController(()=>'a');
 * const { component } = await spec(wrapController(testController));
 * expect(component.controller).toEqual("a");
 *
 * @example
 * class TestController extends Controller {
 *   a = "a";
 * }
 * const {
 *   component: { controller }
 * } = await spec(wrapController(TestController));
 * expect(controller.a).toEqual("a");
 */
declare function wrapController<T>(controller: ((component: BaseComponent & ControllerHost) => T) | (new (component: BaseComponent & ControllerHost) => T), 
/**
 * An optional callback to call right after controller constructor
 */
afterConstruct?: (component: BaseComponent & {
    controller: T;
}) => Promise<void> | void): new () => BaseComponent & {
    controller: T;
};

export { multiSpec, spec, wrapController };
