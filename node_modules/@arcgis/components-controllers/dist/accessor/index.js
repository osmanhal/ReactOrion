import {
  GenericController,
  defaultGetterSetter,
  makeController,
  proxyExports
} from "../chunk-2CDDVOQU.js";
import {
  getPropLikeMembers
} from "../chunk-O63SSNBH.js";
import "../chunk-3KNDPG6Y.js";

// src/accessor/useAccessor.ts
import { importCoreReactiveUtils } from "@arcgis/core-adapter";
import { camelToKebab, isNotUndefined } from "@arcgis/components-utils";
var makeAccessorController = (loadAccessor, _options) => (component, options) => proxy(component, loadAccessor, options);
var AccessorController = class extends GenericController {
  constructor(component, _loadAccessor, _options) {
    super(component);
    this._loadAccessor = _loadAccessor;
    this._options = _options;
    this.reactiveUtils = this.component.reactiveUtils;
    // A mapping from bound component's "prop" name to Accessor instance's "property"
    this._watchedProperties = /* @__PURE__ */ new Map();
    this._isBinding = { value: true };
    this.setProvisionalExports(
      accessorSupport.makeGetterProxy(
        component,
        this._watchedProperties,
        this._isBinding,
        this.constructor.allowedPropNameMismatches
      )
    );
    const integrations = component.manager.internals.reactiveUtilsIntegrations;
    integrations.add(this);
    const reactiveUtilsIntegration = Array.from(integrations).find(
      (integration) => integration instanceof ReactiveUtilsIntegration
    );
    if (reactiveUtilsIntegration) {
      integrations.delete(reactiveUtilsIntegration);
    }
    integrations.add(reactiveUtilsIntegration ?? new ReactiveUtilsIntegration(this.component));
    component.manager.trackPropKey((resolved) => {
      if (resolved) {
        this._instancePropName = resolved;
      }
    }, this.exports);
  }
  hostConnected() {
    this._isBinding.value = false;
  }
  async hostLoad() {
    const component = this.component;
    if (component.reactiveUtils === void 0) {
      this.reactiveUtils = await importCoreReactiveUtils();
    } else {
      this.reactiveUtils = await this.use(component.reactiveUtils);
    }
    const parameters = accessorSupport.gatherParameters(this, this._watchedProperties);
    const finalParameters = this._options?.editConstructorProperties?.call(component, parameters) ?? parameters;
    const awaitedParameters = finalParameters instanceof Promise ? await finalParameters : finalParameters;
    const genericComponent = component;
    const existingInstance = typeof this._instancePropName === "string" ? genericComponent[this._instancePropName] : void 0;
    const hasInstance = existingInstance != null && existingInstance !== this.exports;
    if (hasInstance) {
      this._instance = existingInstance;
      existingInstance.set(awaitedParameters);
    } else {
      this._instance = await this._createInstance(awaitedParameters);
    }
    if (component.manager.destroyed) {
      return;
    }
    accessorSupport.watchComponentUpdates(this, this._instance, this._watchedProperties);
    accessorSupport.watchAccessorUpdates(this, this._instance, this._watchedProperties);
    this.exports = this._instance;
  }
  async _createInstance(parameters) {
    if (this._isAccessorConstructor(this._loadAccessor)) {
      return new this._loadAccessor(parameters);
    } else {
      return await this._loadAccessor(parameters);
    }
  }
  _isAccessorConstructor(loader) {
    return "prototype" in loader && "declaredClass" in loader.prototype;
  }
  hostDestroy() {
    if (this._instance) {
      this._instance.destroy();
    }
  }
  async reCreate() {
    this.hostDestroy();
    await this.hostLoad();
  }
};
var proxy = proxyExports(AccessorController);
var accessorSupport = {
  makeGetterProxy: (component, watchedProperties, isBinding, allowedPropNameMismatches) => new Proxy(
    {},
    {
      /*
       * Without this, makeProvisionalValue() will throw on accessing
       * non-existent prop
       */
      has: (target, prop) => typeof prop === "string" || prop in target,
      get: (target, prop) => {
        const value = Reflect.get(target, prop);
        if (typeof prop === "symbol" || prop in Promise.prototype) {
          return value;
        }
        const hasProp = prop in target;
        const doBinding = isBinding?.value ?? true;
        if (hasProp || !doBinding) {
          return value;
        }
        if (process.env.NODE_ENV !== "production" && watchedProperties.has(prop)) {
          throw new Error(
            `Tried to bind "${prop.toString()}" prop twice. This might also happen if you are trying to access the accessor instance before componentWillLoad()`
          );
        }
        return component.manager.trackKey(
          component,
          (resolved) => {
            if (process.env.NODE_ENV !== "production") {
              if (resolved === void 0) {
                throw new Error(
                  `Unable to resolve what property is "${prop.toString()}" being bound too. Check documentation for useAccessor to ensure proper usage. Make sure you are not trying to access the accessor instance before componentWillLoad()`
                );
              }
              const isFlippingBoolean = resolved.key.toLowerCase().includes("disable");
              const collidesWithNativeProp = prop in HTMLElement.prototype;
              const collidesWithCustomProp = allowedPropNameMismatches?.has(prop) === true;
              if (resolved.key !== prop && !collidesWithNativeProp && !collidesWithCustomProp && !isFlippingBoolean) {
                throw new Error(
                  `Tried to bind "${resolved?.key}" property to "${prop.toString()}" - property names must match`
                );
              }
              if (resolved.type === "property") {
                throw new Error(
                  `For two-way binding with Accessor to work, the property on your component must have @Prop() or @State() decorator. "${prop.toString()}" has neither`
                );
              }
            }
            if (resolved !== void 0) {
              watchedProperties.set(resolved.key, prop);
            }
          },
          value
        );
      }
    }
  ),
  // Update Accessor on component prop change
  watchComponentUpdates(controller, instance, watchedProperties) {
    function getter(_value, propName) {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      return flipBoolean ? !value : value;
    }
    const setter = (newValue, _oldValue, propName) => {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      const currentValue = flipBoolean ? !value : value;
      if (currentValue === newValue) {
        return newValue;
      }
      instance[propertyName] = flipBoolean ? !newValue : newValue;
      const finalValue = instance[propertyName];
      return flipBoolean ? !finalValue : finalValue;
    };
    const component = controller.component;
    const internals = component.manager.internals;
    watchedProperties.forEach((_propName, propertyName) => {
      internals.accessorGetter[propertyName] = getter;
      internals.accessorSetter[propertyName] = setter;
    });
  },
  // Update component on Accessor prop change
  watchAccessorUpdates(controller, instance, watchedProperties) {
    const { component } = controller;
    const genericComponent = component;
    const genericInstance = instance;
    const readonlyProps = findReadOnlyAccessorProps(instance);
    if (process.env.NODE_ENV !== "production") {
      setReadonlyProps?.(controller, readonlyProps);
    }
    component.manager.bypassGetter(
      () => (
        // Careful: Map's forEach callback arguments are (value, key), not (key, value)
        watchedProperties.forEach((propertyName, propName) => {
          if (process.env.NODE_ENV !== "production" && !(propertyName in instance)) {
            throw new Error(`"${propertyName}" does not exist on the accessor instance`);
          }
          if (readonlyProps.has(propertyName)) {
            return;
          }
          const domValue = genericComponent[propName];
          const modelValue = genericInstance[propertyName];
          const flipBoolean = typeof domValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
          const resolvedDomValue = flipBoolean ? !domValue : domValue;
          if (resolvedDomValue != null && modelValue !== resolvedDomValue) {
            genericInstance[propertyName] = resolvedDomValue;
          }
        })
      )
    );
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return Array.from(
        watchedProperties,
        ([propName, propertyName]) => controller.reactiveUtils.watch(
          () => genericInstance[propertyName],
          () => {
            const newValue = genericInstance[propertyName];
            const flipBoolean = typeof newValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
            const resolvedNewValue = flipBoolean ? !newValue : newValue;
            component.manager.bypassSetter(() => {
              genericComponent[propName] = resolvedNewValue;
            });
          },
          { initial: true }
        )
      );
    });
  },
  gatherParameters(controller, watchedProperties) {
    const { component } = controller;
    const data = Object.fromEntries(
      Array.from(watchedProperties, ([prop, property]) => [property, component[prop]]).filter(
        ([, value]) => value !== void 0
      )
    );
    return process.env.NODE_ENV === "production" ? data : filterWatchedProperties?.(controller, data) ?? data;
  },
  reEmitAccessorEvents(controller, instance, reactiveUtils, prefix) {
    const isEvented = "on" in instance && typeof instance.on === "function";
    if (!isEvented) {
      return;
    }
    const toListen = Object.entries(controller.component).map(([key, unknown]) => {
      const value = unknown;
      if (!key.startsWith(prefix) || key === prefix || typeof value !== "object" || value === null || !("emit" in value) || typeof value.emit !== "function") {
        return void 0;
      }
      const emit = value.emit;
      const trimmedEventName = key.slice(prefix.length);
      const camelCaseEventName = camelToKebab(trimmedEventName);
      const eventName = camelCaseEventName.toLowerCase();
      return [eventName, emit];
    }).filter(isNotUndefined);
    if (toListen.length === 0) {
      return;
    }
    const eventTarget = instance;
    const getEventTarget = () => eventTarget;
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return toListen.map(([eventName, emit]) => reactiveUtils.on(getEventTarget, eventName, emit));
    });
  },
  async reCreate(instance, component) {
    const accessorController = component.manager.useRefSync(instance);
    if (accessorController === void 0) {
      if (process.env.NODE_ENV !== "production") {
        console.error("Unable to resolve the useAccessor controller from the provided value");
      }
      return;
    }
    await accessorController.reCreate();
  }
};
function findReadOnlyAccessorProps(instance) {
  const accessor = instance;
  const properties = Object.entries(accessor.__accessor__?.metadata ?? {});
  return new Set(
    properties.filter(([_property, descriptor]) => descriptor?.readOnly === true).map(([property]) => property)
  );
}
var setReadonlyProps = process.env.NODE_ENV === "production" ? void 0 : (controller, properties) => {
  controller.component.manager.devOnlySetPersistentControllerData?.(controller, properties);
};
var filterWatchedProperties = process.env.NODE_ENV === "production" ? void 0 : (controller, data) => {
  const readonlyProperties = controller.component.manager.devOnlyGetPersistentControllerData?.(controller);
  if (readonlyProperties instanceof Set) {
    return Object.fromEntries(Object.entries(data).filter(([key]) => !readonlyProperties.has(key)));
  }
  return data;
};

// src/accessor/reactiveUtilsIntegration.ts
import { importCoreAccessor, importCoreAccessorSupportDecorators } from "@arcgis/core-adapter";
var useReactiveUtilsIntegration = () => makeController((component) => {
  component.manager.internals.reactiveUtilsIntegrations.add(new ReactiveUtilsIntegration(component));
});
var accessorPromise = Promise.all([importCoreAccessor(), importCoreAccessorSupportDecorators()]);
var ReactiveUtilsIntegration = class extends GenericController {
  async hostLoad() {
    const [Accessor, { subclass, property }] = await accessorPromise;
    class AccessorSubclass extends Accessor {
    }
    const getter = (_value, propertyName) => accessor[propertyName];
    function setter(newValue, _oldValue, propertyName) {
      if (accessor !== void 0) {
        accessor[propertyName] = newValue;
      }
      return newValue;
    }
    const component = this.component;
    const internals = component.manager.internals;
    const enabledMembers = [];
    const allMembers = getPropLikeMembers(this.component);
    component.manager.bypassGetter(
      () => allMembers.forEach((name) => {
        const alreadyIntegrated = internals.accessorSetter[name] !== defaultGetterSetter;
        if (alreadyIntegrated) {
          return;
        }
        enabledMembers.push(name);
        internals.accessorGetter[name] = getter;
        internals.accessorSetter[name] = setter;
        property({
          value: component[name]
        })(AccessorSubclass.prototype, name);
      })
    );
    this._enabledMembers = enabledMembers;
    if (enabledMembers.length === 0) {
      return;
    }
    const Subclass = subclass(component.el.tagName)(AccessorSubclass);
    const accessor = new Subclass();
    this._instance = accessor;
  }
  controllerRemoved() {
    super.controllerRemoved();
    const internals = this.component.manager.internals;
    this._instance?.destroy();
    this._enabledMembers?.forEach((name) => {
      internals.accessorGetter[name] = defaultGetterSetter;
      internals.accessorSetter[name] = defaultGetterSetter;
    });
  }
};
export {
  AccessorController,
  ReactiveUtilsIntegration,
  accessorSupport,
  makeAccessorController,
  useReactiveUtilsIntegration
};
