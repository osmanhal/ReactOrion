import { G as GenericController, B as BaseComponent, a as Controller } from '../Controller-BX9TuK8v.cjs';
import '@arcgis/components-utils';
import '@stencil/core';
import '@stencil/core/internal';
import 'lit';

/**
 * Do two-way binding between an instance of an Accessor and component's
 * properties
 */

type Requires<Props, Accessor extends __esri.Accessor> = BaseComponent & Pick<Accessor, keyof Accessor & keyof Props> & {
    reactiveUtils?: typeof __esri.reactiveUtils;
    autoDestroyDisabled: boolean;
    destroy: () => Promise<void>;
};
/**
 * Given an Accessor class, create a controller that will do two-way binding of
 * props between the component and the Accessor
 *
 * See 4.accessor.tsx for documentation & examples
 */
declare const makeAccessorController: <Props, Accessor extends __esri.Accessor, OmitProps extends string = never>(loadAccessor: ((props: Props) => Accessor | Promise<Accessor>) | (new (props: Props) => Accessor), _options?: {
    /**
     * Don't expose the following Widget's properties on the component.
     * You can also bind the property to \@State rather than \@Prop if you
     * wish to use it internally only:
     * @example
     * \@State() timeZone = this.widget.timeZone;
     */
    omitProps: OmitProps[];
} | undefined) => (component: Requires<Omit<Props, OmitProps>, Accessor>, options?: {
    editConstructorProperties(props: Props): Props | Promise<Props>;
} | undefined) => Accessor;
declare class AccessorController<Props, Accessor extends __esri.Accessor, ExtraRequires = Record<never, never>> extends GenericController<Accessor, ExtraRequires & Requires<Props, Accessor>> {
    private _loadAccessor;
    private _options?;
    reactiveUtils: __esri.reactiveUtils;
    protected _instance: Accessor;
    protected _watchedProperties: Map<string, string & keyof Props>;
    private _instancePropName;
    private _isBinding;
    /**
     * (development only) Allow these props to mismatch the name of the Accessor's property
     * to avoid collisions
     *
     * @internal
     */
    static allowedPropNameMismatches?: Set<string>;
    constructor(component: ExtraRequires & Requires<Props, Accessor>, _loadAccessor: ((props: Props) => Accessor | Promise<Accessor>) | (new (props: Props) => Accessor), _options?: {
        editConstructorProperties?(props: Props): Promise<Props> | Props;
    } | undefined);
    hostConnected(): void;
    hostLoad(): Promise<void>;
    private _createInstance;
    private _isAccessorConstructor;
    hostDestroy(): void;
    reCreate(): Promise<void>;
}
declare const accessorSupport: {
    makeGetterProxy: (component: BaseComponent, watchedProperties: Map<string, string>, isBinding?: {
        value: boolean;
    }, allowedPropNameMismatches?: Set<string>) => unknown;
    watchComponentUpdates<T>(controller: Controller<T> & {
        reactiveUtils: __esri.reactiveUtils;
    }, instance: __esri.Accessor, watchedProperties: Map<string, string>): void;
    watchAccessorUpdates<T_1>(controller: Controller<T_1> & {
        reactiveUtils: __esri.reactiveUtils;
    }, instance: __esri.Accessor, watchedProperties: Map<string, string>): void;
    gatherParameters<T_2>(controller: Controller<T_2>, watchedProperties: Map<string, string>): Record<string, unknown>;
    reEmitAccessorEvents<T_3>(controller: Controller<T_3>, instance: __esri.Accessor, reactiveUtils: __esri.reactiveUtils, prefix: string): void;
    reCreate(instance: __esri.Accessor, component: BaseComponent): Promise<void>;
};

/**
 * If this controller is present on the component, reactiveUtils integration
 * will be enabled. With that, you can use reactiveUtils.watch() and other
 * methods to watch for changes on the component's Props and State.
 */
declare const useReactiveUtilsIntegration: () => void;
/**
 * Mirror each component's Prop and State on an Accessor instance, and trigger
 * Accessor's get/set when the component's Prop/State is accessed/modified to
 * integrate Stencil/Lit components with reactiveUtils.
 */
declare class ReactiveUtilsIntegration<Accessor extends __esri.Accessor = __esri.Accessor, Requires = BaseComponent> extends GenericController<Accessor, Requires> {
    protected _instance?: __esri.Accessor;
    protected _enabledMembers?: readonly string[];
    hostLoad(): Promise<void>;
    controllerRemoved(): void;
}

export { AccessorController, ReactiveUtilsIntegration, accessorSupport, makeAccessorController, useReactiveUtilsIntegration };
