import { IHandle, Deferred } from '@arcgis/components-utils';
import { ComponentInterface } from '@stencil/core';
import { HostRef } from '@stencil/core/internal';
import { ReactiveController, ReactiveControllerHost } from 'lit';

type TrackKeyResolution<T> = {
    readonly key: string;
    readonly host: BaseComponent | BaseController;
    readonly type: "prop" | "property" | "state";
    readonly domValue: T | undefined;
};
/**
 * Like ControllerInternals, but specific to each instance of a component
 */
declare class ComponentInternals {
    /**
     * When watchers are set, set then into `allWatchers`. When watchers are read
     * in the setter, read from `enabledWatchers`.
     * On connectedCallback(), controller manager does `enabledWatchers=allWatchers`.
     * Reasoning:
     * - This disables watchers until connected callback (matches behavior of
     *   Stencil's watchers)
     * - This removes in the setter to check if watchers were enabled already or
     *   not (as getters/setters are hot path, and should be streamlined)
     */
    enabledWatchers: Watchers;
    allWatchers: Watchers;
    readonly component: BaseComponent & ControllerHost;
    /**
     * Do not use this directly as it may break on framework updates.
     * Instead, use helpers like getPropMembers and getPropType
     */
    members: HostRef["$cmpMeta$"]["$members$"];
    constructor(component: BaseComponent & ControllerHost);
    trackKey: <T>(hostsCandidates: (BaseComponent | BaseController)[] | BaseComponent | BaseController, onResolved: (resolution: TrackKeyResolution<T> | undefined) => void, defaultValue: T) => T;
    trackPropKey: <T>(onResolved: (key: string | undefined, originalValue: T | undefined) => void, defaultValue: T) => T;
    private _trackedValue;
    private _keyTrackers;
    private _firePropertyTrackers;
    readonly getters: Record<string, ((value: unknown, propertyName: string) => unknown)[] | undefined>;
    readonly setters: Record<string, ((newValue: unknown, oldValue: unknown, propertyName: string) => unknown)[] | undefined>;
    readonly accessorGetter: Record<string, (value: unknown, propertyName: string) => unknown>;
    readonly accessorSetter: Record<string, (newValue: unknown, oldValue: unknown, propertyName: string) => unknown>;
    reactiveUtilsIntegrations: Set<BaseController | Controller<unknown>>;
    /**
     * Configure a getter or setter for a given \@Prop/\@State
     *
     * Note, since props are defined on the prototype, they are shared between all
     * instances of a component. Thus, instead of passing a reference to the
     * getter/setter function, you should update the
     * ComponentInternals.getters/setters properties, and then call getSetProxy
     * to apply the changes to the prototype
     */
    getSetProxy(property: string, hasGetter: boolean, hasSetter: boolean): void;
    private _getSetProxy;
    private _exports;
    /**
     * Associate an exports object with a controller for reverse lookup in
     * controller.use
     */
    markExports(controller: BaseController, exports: unknown): void;
    resolveExports(exports: unknown): BaseController | undefined;
    readonlyProps: Set<string> | undefined;
}
type Watchers = Record<string, ((newValue: unknown, oldValue: unknown, propertyName: string) => void)[] | undefined>;

declare function trackPropertyKey<T>(object: BaseComponent | BaseController, onResolved: (key: string | undefined) => void, defaultValue: T): T;

/**
 * Using "new ControllerManager(this)" inside a component causes this TypeScript
 * error:
 * 'manager' implicitly has type 'any' because it does not have a type
 * annotation and is referenced directly or indirectly in its own initializer.
 *
 * This function fixes that, and it's also a bit shorter to type
 */
declare const useControllerManager: <Component extends BaseComponent>(component: Component, forceUpdate?: ((component: BaseComponent) => void) | undefined) => ControllerManager<Component>;
/**
 * A manager for all other controllers. It finds all controllers on the
 * component, loads them, and forwards lifecycle events to them.
 */
declare class ControllerManager<Component extends BaseComponent = BaseComponent> extends GenericController<undefined, Component> {
    private readonly _controllers;
    readonly internals: ComponentInternals;
    hasDestroy: boolean;
    destroyed: boolean;
    private _updatePromise;
    private _autoDestroyTimeout?;
    /**
     * If true, indicates that ControllerManager is running against a Lit component.
     * Otherwise, means we are running against a Stencil component.
     */
    readonly isLit: boolean;
    constructor(component: Component, forceUpdate?: (component: BaseComponent) => void);
    private _originalLifecycles;
    private _bindLifecycleMethods;
    /**
     * Throws an error if component does not implement destroy() lifecycle, but
     * tries to use it.
     */
    ensureHasDestroy(): void;
    /**
     * Private because this is not supposed to be called by Component directly.
     * Instead, _bindLifecycleMethods will take care of that. Otherwise, you risk
     * calling lifecycle methods twice.
     */
    private _connectedCallback;
    private _disconnectedCallback;
    _load(): Promise<void>;
    _loaded(): void;
    private _update;
    private _updated;
    destroy(): Promise<void>;
    private _autoDestroyDisabledWatcher;
    /**
     * A magical solution to finding out what property name a given controller
     * on a given object was assigned to. Note, this does not work for properties
     * that have \@Prop() or \@State() decorator - for those, use
     * manager.trackPropKey() instead.
     *
     * @example
     * function trackMe<T>(defaultValue:T, component:BaseComponent):T {
     *   component.manager.trackPropertyKey(component, (key)=>console.log(key), defaultValue);
     *   return defaultValue;
     * }
     *
     * class MyComponent extends BaseComponent {
     *   // Will console log "myProp"
     *   myProp = trackMe('a', this);
     * }
     *
     */
    trackPropertyKey: typeof trackPropertyKey;
    /**
     * Like manager.trackPropertyKey(), but for props that have \@State() or \@Prop()
     * decorator
     *
     * @example
     * function trackMe(component:BaseComponent) {
     *   component.manager.trackPropKey((key)=>console.log(key));
     * }
     *
     * class MyComponent extends BaseComponent {
     *   // Will console log "myProp"
     *   @Prop() myProp = trackMe(this);
     *
     *   // Will console log "myState"
     *   @State() myState = trackMe(this);
     * }
     */
    trackPropKey: <T>(onResolved: (key: string | undefined, originalValue: T | undefined) => void, defaultValue: T) => T;
    /**
     * A combination of trackPropertyKey() and trackPropKey(). For usage when
     * you want to track a property, but don't know if it will be defined with the
     * \@Prop() decorator or not
     */
    trackKey: <T>(hostsCandidates: BaseComponent | BaseController | (BaseComponent | BaseController)[], onResolved: (resolution: TrackKeyResolution<T> | undefined) => void, defaultValue: T) => T;
    /**
     * Make a @Prop() or @State() readonly (prevent overwriting default value).
     *
     * For internal properties, prefer TypeScript's "readonly" modifier instead.
     *
     * @example
     * // Defining readonly prop
     * @Prop({ reflect: true }) prop = this.manager.readonly('a');
     *
     * @example
     * // Overwriting readonly prop internally
     * this.manager.bypassReadonly(()=>{
     *   this.prop = 'b';
     * });
     *
     */
    readonly<T>(value: T): T;
    private _readonlySetter;
    /**
     * Listen for any component's @State()/@Prop() change, and mutate it's
     * value before it is set.
     * This is necessary because Stencil's Compiler does not support get/set for
     * @State()/@Prop().
     * For private component properties, you should use regular get/set syntax.
     *
     * @example
     * @Prop() exampleProp = this.manager.getSet(defaultValue,{get,set})
     * @Prop() someProp = this.manager.getSet(
     *   undefined as string | undefined,
     *   {
     *     get: (value)=>value.trim(),
     *     set: (newValue,oldValue) => newValue.trim() ?? oldValue
     *   }
     * )
     *
     * @remarks
     * Unlike a native get/set, the get function receives the current attribute
     * value, and can modify it before returning it (or can disregard the current
     * value and get it from elsewhere instead).
     * Similarly, setter is called with the new and old value, and is expected to
     * return the final new value (or return the old value to undo the change)
     */
    getSet<T>(
    /**
     * Default value is used only if user did not set a value in the DOM before
     * component was loaded
     */
    defaultValue: T, getSet: {
        /**
         * Whether to call setter right away if the value was set in the DOM before
         * component even loaded. Default: true
         */
        initialSet?: false;
    } & ({
        get?(newValue: T, propertyName: string): T;
        set(newValue: T, oldValue: T, propertyName: string): T;
    } | {
        get(newValue: T, propertyName: string): T;
        set?(newValue: T, oldValue: T, propertyName: string): T;
    } | {
        get(newValue: T, propertyName: string): T;
        set: "ignore";
    })): T;
    /**
     * In development, on hot module reload, controller would be re-initialized
     * with all Props and State values persistent, but properties lost. This unsafe
     * development-only API lets you set or get data for a controller that would
     * persist across hot reloads.
     */
    devOnlySetPersistentControllerData?: (controller: BaseController, data: unknown) => void;
    devOnlyGetPersistentControllerData?: <T>(controller: BaseController) => T | undefined;
}

type SafeComponentInterface = Pick<ComponentInterface, "componentDidLoad" | "componentDidUpdate" | "componentShouldUpdate" | "componentWillLoad" | "componentWillUpdate" | "connectedCallback" | "disconnectedCallback">;
/**
 * Properties required on all components that use a controller
 */
type BaseComponent = SafeComponentInterface & {
    manager: ControllerManager;
    el: HTMLElement;
    autoDestroyDisabled?: boolean;
    destroy?: () => Promise<void>;
};
/**
 * Helper utility to get component type from a controller. Can be used in
 * "implements"
 * @example
 * const useHomeViewModel = makeViewModelController(newWidgetsHomeHomeViewModel);
 * export class Home implements Use<typeof useHomeViewModel> {
 * // No need for "implements BaseComponent" as that's already included in
 * // every controller
 *
 * @remarks
 * TypeScript detects errors even without Use<typeof useHomeViewModel>, but Use
 * makes errors display in a more readable format
 */
type Use<Callback extends (component: any) => unknown> = Parameters<Callback>[0];
/**
 * Base API for a controller. Compatible with both Lit's Reactive controllers
 * and Stencil's lifecycle
 */
type ControllerLifecycleMethods = {
    readonly hostConnected?: ReactiveController["hostConnected"];
    readonly hostDisconnected?: ReactiveController["hostDisconnected"];
    readonly hostLoad?: ComponentInterface["componentWillLoad"];
    readonly hostLoaded?: ComponentInterface["componentDidLoad"];
    readonly hostUpdate?: ReactiveController["hostUpdate"];
    readonly hostUpdated?: ReactiveController["hostUpdated"];
    /**
     * Called when the component is finally being destroyed (rather than
     * temporary disconnected from the DOM)
     */
    readonly hostDestroy?: () => void;
    /**
     * lifecycle() is a convenience higher-level callback that:
     * - calls the provided callback right away the first time if
     *   connectedCallback has already happened once
     *   - otherwise, calls it on connectedCallback
     * - calls the callback on each future connectedCallback
     * - if you returned a function, or an object like {remove:()=>void}, that
     *   function will be called on the next disconnectedCallback
     *
     * This is a bit like useEffect(callback, []) in React
     */
    readonly hostLifecycle?: () => (() => void)[] | IHandle | IHandle[] | (() => void) | undefined | void;
    /**
     * Called after component.removeComponent(controller) was called on this
     * controller
     */
    readonly controllerRemoved?: () => void;
};
/**
 * Controller host interface, compatible with both Lit's Reactive controllers
 * and Stencil's lifecycle.
 * These members are added to the component instance by ControllerManager.
 */
type ControllerHost = {
    /**
     * Adds a controller to the host, which connects the controller's lifecycle
     * methods to the host's lifecycle.
     */
    addController: (controller: BaseController) => void;
    /**
     * Removes a controller from the host.
     */
    removeController: (controller: BaseController) => void;
    requestUpdate: ReactiveControllerHost["requestUpdate"];
    readonly updateComplete: ReactiveControllerHost["updateComplete"];
};
/**
 * A symbol is used to mark providers/controllers on a component instance.
 * This helps to distinguish them from regular properties.
 */
declare const controllerSymbol: unique symbol;
/**
 * Adding an optional symbol to satisfy TypeScript
 * "type Controller has no properties in common with BaseController"
 */
type BaseController = ControllerLifecycleMethods & {
    readonly [controllerSymbol]?: true;
};

/**
 * A bundle of small behind-the-scenes utils that improve DX for controllers,
 * powering features like implicit component reference passing and
 * proxyExports()
 */
declare class ControllerInternals {
    private _ambientComponent;
    setAmbientComponent(component: BaseComponent): void;
    retrieveComponent(name?: string): BaseComponent;
    private _ambientControllers;
    setParentController(controller: BaseController | undefined): void;
    retrieveParentControllers(): readonly BaseController[];
    private _ambientChildController;
    setAmbientChildController(controller: BaseController | undefined): void;
    retrieveAmbientChildController(): BaseController | undefined;
    /**
     * The type definition has to be duplicated due to the
     * "'use' is referenced directly or indirectly in its own type annotation."
     * error
     */
    use: <Value>(value: Value, watchExports?: (value: NotNever<InferController<Value>>, unsubscribe: () => void) => void) => Promise<NotNever<InferController<Value>>>;
    useRef: <Value>(value: Value) => Promise<InferController<Value>>;
    useRefSync: <Value>(value: Value) => InferController<Value> | undefined;
    shouldBypassSetter: boolean;
    shouldBypassGetter: boolean;
    shouldBypassReadonly: boolean;
    /**
     * A map from component instance or component element to component instance.
     * To get from component instance or component element to component element,
     * you can just use the .el property
     */
    elementToInstance: WeakMap<BaseComponent | HTMLElement, BaseComponent>;
}
/**
 * If passed value is a controller, then return it. Otherwise, assume it's a
 * proxyExports() result and wrap it into a controller
 *
 * Note, this won't type correctly if a proxyExports() controller is exporting a
 * non-proxyExports() controller
 */
type InferController<ControllerOrExports> = ControllerOrExports extends BaseController ? ControllerOrExports & {
    exports?: unknown;
    ready?: Promise<void>;
    watchExports?: Controller["watchExports"];
} : Controller<ControllerOrExports>;
/**
 * If controller never sets it's exports, then it's default exports is "this".
 * This allows usage of controller.use with controllers that don't have exports
 */
type NotNever<T extends {
    exports?: any;
}> = T extends {
    exports: never;
} ? T : T["exports"];

/**
 * Base class for Controllers defined using a class rather than a function.
 * Defining controller using makeController() function is more succinct for smaller
 * controllers. For controllers that need to declare several methods, or need
 * more flexibility, this class may be used
 *
 * See ./examples.tsx for many example controllers and their usages.
 */
declare abstract class Controller<Exports = never> implements BaseController {
    protected _callbacks: {
        readonly [KEY in keyof Omit<ControllerLifecycleMethods, "controllerRemoved">]-?: NonNullable<ControllerLifecycleMethods[KEY]>[];
    };
    protected _ready: Deferred<Exports>;
    private _lifecycleDisconnected;
    connectedCalled: boolean;
    willLoadCalled: boolean;
    didLoadCalled: boolean;
    readonly [controllerSymbol] = true;
    component: BaseComponent & ControllerHost;
    ready: Promise<Exports>;
    static readonly internals: ControllerInternals;
    constructor(component?: BaseComponent);
    /**
     * If controller is being added dynamically, after the component
     * construction, then trigger connected and load right away
     */
    catchUpLifecycle(): void;
    private _exports;
    get exports(): Exports;
    /**
     * Set controller's exports property (for usage with proxyExports()) and mark
     * controller as ready (for usage in other controllers). Also, triggers
     * re-render of the component
     */
    set exports(exports: Exports);
    /**
     * If controller needs to await a promise before it's exports are fully ready
     * but it wishes to make some limited exports available before then,
     * this method can be used.
     *
     * This is useful for permitting a limited usage of the controller in default
     * values of properties or in component constructor.
     *
     * In order to help detect bugs, trying to access a prop on the exports value
     * that does not exist will throw an error (in development only). This is
     * useful to detect usages of controller that forgot to await it's exports.
     * (the "value in this.myController" check won't cause an exception though)
     */
    setProvisionalExports(exports: Exports): void;
    setProvisionalExports(exports: Exports extends object ? Partial<Exports> : Exports): void;
    setProvisionalExports<Props extends keyof Exports>(exports: Pick<Exports, Props>): void;
    _exportWatchers: Set<() => void>;
    watchExports(callback: (exports: Exports) => void): () => void;
    /**
     * A flexible utility for making sure a controller is loaded before it's used,
     * regardless of how or where a controller was defined:
     *
     * @example
     * makeGenericController(async (component, controller) => {
     *   // Await some controller from the component:
     *   await controller.use(component.someController);
     *   // Initialize new controllers
     *   await controller.use(load(importCoreReactiveUtils));
     *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
     *   await controller.use(someController(component));
     * });
     *
     * @remarks
     * If your controller is not async, and you are not creating it async, then
     * you are not required to use controller.use - you can use it directly.
     * Similarly, accessing controllers after componentWillLoad callback does not
     * require awaiting them as they are guaranteed to be loaded by then.
     */
    get use(): typeof Controller.internals.use;
    /**
     * Just like controller.use, but returns the controller itself, rather than it's
     * exports
     *
     * Use cases:
     * - You have a controller and you want to make sure it's loaded before you
     *   try to use it
     * - Your controller is not using exports, so you wish to access some props on
     *   it directly
     * - You have a controller exports only, and you want to retrieve the
     *   controller itself. This is useful if you wish to call .watchExports() or
     *   some other method on the controller
     */
    get useRef(): typeof Controller.internals.useRef;
    /**
     * Like useRef, but doesn't wait for the controller to get ready
     */
    get useRefSync(): typeof Controller.internals.useRefSync;
    /**
     * If you need to set a prop/state without triggering the custom setter you
     * defined with getSet()/dynamicGetSet()/readonly(), set the value inside
     * of this function
     *
     * @example
     * @Prop() readOnly = this.manager.readOnly(true);
     *
     * someAction(): void {
     *   this.manager.bypassSetter(()=>{
     *     this.readOnly = false;
     *   });
     * }
     *
     */
    bypassSetter<T = void>(callback: () => T): T | void;
    /**
     * Like bypassSetter, but only bypasses this.manager.readonly(), rather that
     * all setters set using this.manager.getSet()
     */
    bypassReadonly<T = void>(callback: () => T): T | void;
    /**
     * Property reads inside of this function will bypass any custom getter you
     * may have, and read the value directly from what's stored in Stencil/Lit.
     *
     * This also bypasses reactiveUtils integration - reading a property inside of
     * bypassGetter won't make that property tracked.
     *
     * @example
     * reactiveUtils.watch(
     *   ()=>{
     *     this.manager.bypassGetter(()=>{
     *       console.log(this.someProp);
     *     });
     *     return this.prop;
     *   },
     *   console.log
     * )
     */
    bypassGetter<T = void>(callback: () => T): T | void;
    /**
     * Like this.manager.getSet(), but can be called on any component's
     * state/prop from anywhere, rather than just from the default value
     */
    dynamicGetSet<Property extends keyof BaseComponent>(name: Property, getSet: {
        get?(newValue: BaseComponent[Property], propertyName: Property): BaseComponent[Property];
        set(newValue: BaseComponent[Property], oldValue: BaseComponent[Property], propertyName: Property): BaseComponent[Property];
    } | {
        get(newValue: BaseComponent[Property], propertyName: Property): BaseComponent[Property];
        set?(newValue: BaseComponent[Property], oldValue: BaseComponent[Property], propertyName: Property): BaseComponent[Property];
    }): void;
    /**
     * Like dynamicGetSet, but less type-safe. Useful in cases when trying to set
     * getters/setters in place where property names & types are not known
     * statically
     */
    genericGetSet<Type>(property: string, getSet: {
        get?(newValue: Type, propertyName: string): Type;
        set(newValue: Type, oldValue: Type, propertyName: string): Type;
    } | {
        get(newValue: Type, propertyName: string): Type;
        set?(newValue: Type, oldValue: Type, propertyName: string): Type;
    } | {
        get(newValue: Type, propertyName: string): Type;
        set: "ignore";
    }): void;
    /**
     * Dynamically set a watcher for any reactive property
     */
    watch<Property extends keyof BaseComponent>(property: Property, callback: (newValue: BaseComponent[Property], oldValue: BaseComponent[Property], property: Property) => void): () => void;
    controllerRemoved(): void;
    onConnected(callback: NonNullable<ControllerLifecycleMethods["hostConnected"]>): void;
    onDisconnected(callback: NonNullable<ControllerLifecycleMethods["hostDisconnected"]>): void;
    onLoad(callback: NonNullable<ControllerLifecycleMethods["hostLoad"]>): void;
    onLoaded(callback: NonNullable<ControllerLifecycleMethods["hostLoaded"]>): void;
    onUpdate(callback: NonNullable<ControllerLifecycleMethods["hostUpdate"]>): void;
    onUpdated(callback: NonNullable<ControllerLifecycleMethods["hostUpdated"]>): void;
    onDestroy(callback: NonNullable<ControllerLifecycleMethods["hostDestroy"]>): void;
    onLifecycle(callback: NonNullable<ControllerLifecycleMethods["hostLifecycle"]>): void;
    triggerConnected(): void;
    triggerDisconnected(): void;
    triggerLoad(): Promise<void>;
    triggerLoaded(): void;
    triggerUpdate(): void;
    triggerUpdated(): void;
    triggerDestroy(): void;
    triggerLifecycle(): void;
    _callLifecycle(callback: NonNullable<ControllerLifecycleMethods["hostLifecycle"]>): void;
}
/**
 * If your controller requires some specific properties to be present on the
 * component, besides what's included in the BaseComponent, use
 * GenericController over the usual Controller. Use the 2nd generic argument
 * on this class for specifying what properties your controller expects on the
 * component
 *
 * When using a controller created using GenericController, consumer must
 * pass in "this" explicitly to the constructor. If controller was
 * created using Controller, that is not necessary
 */
declare abstract class GenericController<Exports, Requires = BaseComponent> extends Controller<Exports> {
    component: BaseComponent & ControllerHost & Requires;
    constructor(component: BaseComponent & Requires);
    watch<Property extends keyof (BaseComponent & Requires)>(property: Property, callback: (newValue: (BaseComponent & Requires)[Property], oldValue: (BaseComponent & Requires)[Property], property: Property) => void): () => void;
    dynamicGetSet<Property extends keyof (BaseComponent & Requires)>(property: Property, getSet: {
        get?(newValue: (BaseComponent & Requires)[Property], propertyName: Property): (BaseComponent & Requires)[Property];
        set(newValue: (BaseComponent & Requires)[Property], oldValue: (BaseComponent & Requires)[Property], propertyName: Property): (BaseComponent & Requires)[Property];
    } | {
        get(newValue: (BaseComponent & Requires)[Property], propertyName: Property): (BaseComponent & Requires)[Property];
        set?(newValue: (BaseComponent & Requires)[Property], oldValue: (BaseComponent & Requires)[Property], propertyName: Property): (BaseComponent & Requires)[Property];
    }): void;
}

export { type BaseComponent as B, type ControllerHost as C, GenericController as G, type SafeComponentInterface as S, type Use as U, Controller as a, ControllerManager as b, type ControllerLifecycleMethods as c, controllerSymbol as d, type BaseController as e, useControllerManager as u };
