import {
  Controller,
  makeController
} from "./chunk-2CDDVOQU.js";
import {
  getPropMembers
} from "./chunk-O63SSNBH.js";

// src/load.ts
var load = (loader) => makeController(loader);

// src/toFunction.ts
var toFunction = (Class) => (...args) => {
  const ambientControllers = Controller.internals.retrieveParentControllers();
  const instance = new Class(...args);
  Controller.internals.setParentController(ambientControllers.at(-1));
  return instance;
};

// src/Handles.ts
var Handles = class _Handles {
  constructor() {
    //--------------------------------------------------------------------------
    //
    //  Variables
    //
    //--------------------------------------------------------------------------
    this._groups = /* @__PURE__ */ new Map();
  }
  /**
   * A handle to a {@link module:esri/views/layers/FeatureLayerView#highlight highlight} call result.
   * The handle can be used to remove the installed highlight.
   *
   * @typedef module:esri/core/Handles~Handle
   *
   * @property {Function} remove - Removes the handle.
   */
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  /**
   * Destroys the object, removing all the handles.
   *
   * @method destroy
   * @instance
   *
   * @example
   * let handles = new Handles();
   *
   * handles.add(reactiveUtils.when(
   *   () => !view.updating,
   *   () => {
   *     wkidSelect.disabled = false;
   *   },
   *   { once: true }
   * ));
   *
   * handles.destroy();
   */
  destroy() {
    this.removeAll();
  }
  //--------------------------------------------------------------------------
  //
  //  Properties
  //
  //--------------------------------------------------------------------------
  /**
   * Handle count. Used for unit testing.
   * @return {number}
   * @private
   */
  get size() {
    let total = 0;
    this._groups.forEach((group) => {
      total += group.length;
    });
    return total;
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Adds a group of handles.
   * @method add
   * @param {module:esri/core/Accessor~WatchHandle | module:esri/core/Accessor~WatchHandle[] | module:esri/core/Collection<module:esri/core/Accessor~WatchHandle>} handles - An array or collection handles to group.
   * @param {*} [groupKey]
   *    Key identifying the group to which the handles should be added. All the handles in the group
   *    can later be removed with {@link module:esri/core/Handles#remove Handles.remove()}. If no
   *    key is provided the handles are added to a default group.
   *
   * @example
   * let handles = new Handles();
   *
   * handles.add(handle); // added to the default group
   * handles.add([handle1, handle2]); // added to the default group
   *
   * handles.add(handle, "handle-group");
   * handles.add([handle1, handle2], "other-handle-group");
   *
   * @example
   * let handles = new Handles();
   *
   * handles.add(reactiveUtils.when(
   *   () => !view.updating,
   *   () => {
   *     wkidSelect.disabled = false;
   *   },
   *   { once: true }
   * ));
   * @instance
   */
  add(handles, groupKey) {
    if (Array.isArray(handles)) {
      const group = this._getOrCreateGroup(groupKey);
      for (const handle of handles) {
        if (this._isHandle(handle)) {
          group.push(handle);
        }
      }
    } else if (this._isHandle(handles)) {
      const group = this._getOrCreateGroup(groupKey);
      group.push(handles);
    }
    return this;
  }
  forEach(keyOrCallback, callback) {
    if (typeof keyOrCallback === "function") {
      this._groups.forEach((group) => group.forEach(keyOrCallback));
    } else {
      const handles = this._getGroup(keyOrCallback);
      if (handles && callback) {
        handles.forEach(callback);
      }
    }
  }
  /**
   * Returns true if a group exists for the provided group key, false otherwise.
   * @method has
   * @instance
   *
   * @param {*} groupKey - group handle key
   *
   * @return {boolean}
   */
  has(groupKey) {
    return this._groups.has(this._ensureGroupKey(groupKey));
  }
  /**
   * Removes a group of handles.
   *
   * @method remove
   * @instance
   *
   * @param {*} [groupKey] - A group key or an array or collection of group keys to remove.
   *
   * @example
   * let handles = new Handles();
   *
   * handles.remove(); // removes handles from default group
   *
   * handles.remove("handle-group");
   * handles.remove("other-handle-group");
   */
  remove(groupKey) {
    if (typeof groupKey !== "string" && Array.isArray(groupKey)) {
      for (const k of groupKey) {
        this.remove(k);
      }
      return this;
    }
    if (!this.has(groupKey)) {
      return this;
    }
    this._removeAllFromGroup(this._getGroup(groupKey));
    this._groups.delete(this._ensureGroupKey(groupKey));
    return this;
  }
  /**
   * Removes all handles.
   *
   * @method removeAll
   * @instance
   */
  removeAll() {
    this._groups.forEach((group) => this._removeAllFromGroup(group));
    this._groups.clear();
    return this;
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  _isHandle(handle) {
    return handle && (!!handle.remove || handle instanceof _Handles);
  }
  _getOrCreateGroup(key) {
    if (this.has(key)) {
      return this._getGroup(key);
    }
    const group = [];
    this._groups.set(this._ensureGroupKey(key), group);
    return group;
  }
  _getGroup(key) {
    return this._groups.get(this._ensureGroupKey(key));
  }
  _ensureGroupKey(key) {
    return key || "_default_";
  }
  _removeAllFromGroup(group) {
    for (const handle of group) {
      if (handle instanceof _Handles) {
        handle.removeAll();
      } else {
        handle.remove();
      }
    }
  }
};

// src/useHandles.ts
var HandleManager = class extends Controller {
  constructor(removeOn) {
    super();
    this.destroyed = false;
    if (removeOn === "disconnect") {
      this.onDisconnected(() => this.removeAllHandles());
    } else {
      this.onDestroy(() => this.destroy());
    }
  }
  /**
   * Adds one or more handles which are to be tied to the lifecycle of the object. The handles will
   * be removed when the object is destroyed.
   *
   * ```js
   * // Manually manage handles
   * const handle = reactiveUtils.when(
   *   () => !view.updating,
   *   () => {
   *     wkidSelect.disabled = false;
   *   },
   *   { once: true }
   * );
   *
   * this.addHandles(handle);
   *
   * // Destroy the object
   * this.destroy();
   * ```
   * @method addHandles
   * @since 4.25
   * @instance
   * @param {module:esri/core/Accessor~WatchHandle | module:esri/core/Accessor~WatchHandle[]} handleOrHandles
   *    Handles marked for removal once the object is destroyed.
   * @param {*} [groupKey]
   *    Key identifying the group to which the handles should be added. All the handles in the group
   *    can later be removed with {@link module:esri/core/Accessor#removeHandles Accessor.removeHandles()}.
   *    If no key is provided the handles are added to a default group.
   */
  addHandles(handleOrHandles, groupKey) {
    if (this.destroyed) {
      const handlesToAdd = Array.isArray(handleOrHandles) ? handleOrHandles : [handleOrHandles];
      for (const handle of handlesToAdd) {
        handle.remove();
      }
      return;
    }
    this._handles ?? (this._handles = new Handles());
    this._handles.add(handleOrHandles, groupKey);
  }
  /**
   * Removes a group of handles owned by the object.
   *
   * @method removeHandles
   * @since 4.25
   * @instance
   *
   * @param {*} [groupKey] - A group key or an array or collection of group keys to remove.
   *
   * @example
   * obj.removeHandles(); // removes handles from default group
   *
   * obj.removeHandles("handle-group");
   * obj.removeHandles("other-handle-group");
   */
  removeHandles(groupKey) {
    this._handles?.remove(groupKey);
  }
  /**
   * Removes all the handles currently associated with the object.
   *
   * @ignore
   */
  removeAllHandles() {
    this._handles?.removeAll();
  }
  destroy() {
    this.destroyed = true;
    this.removeAllHandles();
  }
  /**
   * Returns true if a named group of handles exist.
   *
   * @method hasHandles
   * @since 4.25
   * @instance
   * @param {*} [groupKey] - A group key.
   * @return {boolean} Returns `true` if a named group of handles exist.
   *
   * @example
   * // Remove a named group of handles if they exist.
   * if (obj.hasHandles("watch-view-updates")) {
   *   obj.removeHandles("watch-view-updates");
   * }
   */
  hasHandles(groupKey) {
    return this._handles?.has(groupKey) ?? false;
  }
};
var useHandles = toFunction(HandleManager);

// src/useT9n.ts
import { getElementLocales, startLocaleObserver } from "@arcgis/components-utils";
var makeT9nController = (getAssetPath) => ({ blocking = false, name } = {}) => (
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  makeController((component, controller) => {
    controller.onLifecycle(
      () => startLocaleObserver(
        component.el,
        getAssetPath("./assets"),
        ({ t9nLocale, t9nStrings, lang }) => {
          controller.exports = { ...t9nStrings, _lang: lang, _t9nLocale: t9nLocale };
          const label = t9nStrings.componentLabel ?? t9nStrings.widgetLabel;
          if (typeof label === "string" && "label" in component && component.label == null) {
            component.label ?? (component.label = label);
          }
        },
        name
      )
    );
    if (blocking) {
      return controller.ready;
    }
    const locale = getElementLocales(component.el);
    return { _lang: locale.lang, _t9nLocale: locale.t9nLocale };
  })
);

// src/usePropertyChange.ts
var usePropertyChange = (_component) => propertyChangeController;
var eventName = "arcgisPropertyChange";
var propertyChangeController = (...toWatch) => makeController((component, controller) => {
  const eventedComponent = component;
  if (component.manager.isLit) {
    eventedComponent[eventName] = {
      emit: (payload) => {
        const event = new CustomEvent(eventName, { detail: payload, cancelable: true });
        component.el.dispatchEvent(event);
        return event;
      }
    };
  }
  const eventEmitter = eventedComponent[eventName];
  if (process.env.NODE_ENV !== "production") {
    if (typeof eventEmitter !== "object" || eventEmitter === null || !("emit" in eventEmitter) || typeof eventEmitter.emit !== "function") {
      throw new Error(
        `For consistency, usePropertyChange must be assigned to an arcgisPropertyChange property that has an @Event({cancelable:true}) decorator`
      );
    }
    const allProps = new Set(getPropMembers(component));
    toWatch.forEach((prop) => {
      if (!allProps.has(prop)) {
        throw new Error(
          prop in component ? `For usePropertyChange to emit event on "${prop}" property change, you should add @${component.manager.isLit ? "property" : "Prop"}() to ${prop} in ${component.el.tagName.toLowerCase()}` : `usePropertyChange can't emit event on "${prop}" property change as such property does not exist in ${component.el.tagName.toLowerCase()}`
        );
      }
    });
  }
  controller.onLoad(
    () => controller.onLifecycle(
      () => toWatch.map(
        (name) => (
          // Casting to 'el' to simplify dynamic prop name typing
          component.manager.watch(name, () => eventEmitter.emit({ name }))
        )
      )
    )
  );
  return eventEmitter;
});

export {
  load,
  toFunction,
  useHandles,
  makeT9nController,
  usePropertyChange
};
