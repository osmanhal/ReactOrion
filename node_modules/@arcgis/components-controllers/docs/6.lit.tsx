import { Element } from "@stencil/core";
import type { ControllerManager, BaseComponent, ControllerHost } from "../src";
import { Controller, useControllerManager, proxyExports } from "../src";
import { example } from "./1.functional";
import type { ReactiveController, ReactiveControllerHost } from "lit";

// Purely accidentally, we named this pattern very similar to the Reactive
// Controllers feature in Lit
// (https://lit.dev/docs/composition/controllers/).
// This is before we were aware that Lit had Controllers. Given the
// remarkable similarity between Lit Controllers and this "Stencil Controllers"
// pattern, it stands to reason that this pattern is useful and has a place in
// the Web components ecosystem.

// After this, Lit's Controllers were used as an inspiration for improving the
// API. Stencil Controllers were expanded to be fully compatible with Lit's
// Controllers, while adding usability improvements like a functional syntax,
// optional "this" argument, Stencil-specific features, and the `destroy()`
// lifecycle method.

// This means, we benefit from the Lit's much larger ecosystem and can use
// features like Lit's context library
// (https://www.npmjs.com/package/@lit/context).

// In addition an experimental vue-lit library
// (https://github.com/yyx990803/vue-lit) that binds Lit's controllers and Vue's
// reactivity library was used as an inspiration for lifecycle methods in
// functional controllers.

// Fun fact:
// â Stencil community asked for Lit's controllers to be added 3 years ago
// (https://github.com/ionic-team/stencil/issues/3162)

example("1. Using Lit's controllers in Stencil", () => {
  // A Lit controller is just a class that implements any of these 4 methods:
  // - hostConnected
  // - hostDisconnected
  // - hostUpdate
  // - hostUpdated
  class LitController implements ReactiveController {
    constructor(public component: ReactiveControllerHost) {
      this.component = component;
      // A lit controller also expects to receive a reference to the host as the
      // first argument in it's constructor, and it will call "addController" on
      // the host to register itself with the host:
      this.component.addController(this);
    }
    hostConnected(): void {
      console.log(this.component, "host connected");
    }
    hostDisconnected(): void {
      console.log(this.component, "host disconnected");
    }
    hostUpdate(): void {
      console.log(this.component, "host update");
    }
    hostUpdated(): void {
      console.log(this.component, "host updated");
    }
  }
  // See more in https://lit.dev/docs/composition/controllers/#lifecycle
  // Class-based Stencil controllers intentionally were designed in such a way
  // as to match, and extend, this API.

  // You may have noticed that Lit's controllers expect a
  // ReactiveControllerHost as a component type. ReactiveControllerHost
  // is supposed to implement a few members we don't have on our Stencil
  // components:
  // - addController(controller: ReactiveController): void
  // - removeController(controller: ReactiveController): void
  // - requestUpdate(): void
  // - updateComplete: Promise<void>
  // In the name of reducing boilerplate, we are not requiring you add these.
  // Instead, ControllerManager adds them automatically at run-time, and the
  // Controller class is using them already behind the scenes.
  //
  // Since TypeScript is not aware that these members are added to your component
  // dynamically, when using a Lit controller in Stencil, you have to pass
  // "this.manager.component" rather than "this" to avoid a TypeScript error.

  class ExampleComponent1 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // TypeScript won't let you just pass "this" because it does not have the
    // required members. Instead, you have to pass this.manager.component,
    // which is equivalent to "this", but has the typing for the required
    // members:
    lifecycle = new LitController(this.manager.component);
  }

  // And just like that, any Lit controller is usable in Stencil.
  // See some great controllers to try out:
  // Lit Context: https://lit.dev/docs/data/context/
  // Lit Async tasks: https://lit.dev/docs/data/task/
  // Adobe's Reactive Controllers: https://opensource.adobe.com/spectrum-web-components/tools/reactive-controllers/
  // A collection of lit libraries: https://github.com/web-padawan/awesome-lit

  // You can of course create your own wrapper for any Lit controller that
  // would reduce boilerplate a bit.
  // Controller.internals.retrieveComponent() can also be used to implicitly
  // get a reference to the current component

  const useLitController = (): LitController =>
    new LitController(Controller.internals.retrieveComponent().manager.component);

  class ExampleComponent1a implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // Much less boilerplate! ðŸ˜‹
    lifecycle = useLitController();
  }

  return [ExampleComponent1, ExampleComponent1a];
});

example("2. (Under the hood) proxyExports() in Lit controllers", () => {
  // For proxyExports() to work, you have to use it in a component that has
  // ControllerManager, or in a controller that has the following line in the
  // constructor of the superclass:
  // Controller.internals.setParentController(this);
  // (Controller class has that)
  // It has to be in the superclass so that it's executed before default values
  // are set in the subclass.

  // eslint-disable-next-line @typescript-eslint/no-extraneous-class
  class ProxyExportsHost {
    constructor() {
      // This will let proxyExports() know which controller it's used in
      Controller.internals.setParentController(this);
    }
  }

  class ProxyExportsHostInstance extends ProxyExportsHost {
    public a: string;
    constructor(public component: BaseComponent & ControllerHost) {
      super();
      this.a = useSomeProxy(component);
    }
  }

  class SomeController {
    exports = "default";

    constructor(public component: BaseComponent & ControllerHost) {
      setTimeout(() => {
        this.exports = "updated";
      }, 1);
    }

    private _exportsWatchers = new Set<(exports: string) => void>();

    // "exports" and "watchExports" members must be present for proxyExports to
    // work
    watchExports(watch: (exports: string) => void): () => void {
      this._exportsWatchers.add(watch);
      return () => this._exportsWatchers.delete(watch);
    }
  }
  const useSomeProxy = proxyExports(SomeController);

  return ProxyExportsHostInstance;
});

/*** The end ***/

// Now, take a look at the roadmap for Controllers in ./7.future.md, or go and
// build something cool using Controllers!

// Have feedback, questions or need help?
// Make a post in this GitHub Discussion:
// https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/711
