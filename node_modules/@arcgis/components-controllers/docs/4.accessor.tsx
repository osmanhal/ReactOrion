import { Element, Prop, State, forceUpdate } from "@stencil/core";
import type { BaseComponent, ControllerManager, Use } from "../src";
import { useControllerManager, load } from "../src";
import { makeAccessorController } from "../src/accessor";
import { example } from "./1.functional";
import type { Nil } from "@arcgis/components-utils";
import {
  importCoreAccessor,
  importCoreAccessorSupportDecorators,
  importCoreReactiveUtils,
  newWidgetsHomeHomeViewModel,
} from "@arcgis/core-adapter";

const Accessor = await importCoreAccessor();
const { subclass, property } = await importCoreAccessorSupportDecorators();

// The most important pattern used across JS API and related projects is
// View<-->ViewModel. Each component/view has a corresponding ViewModel that
// stores the state, but also has method for updating the state. Then, the
// view/component only needs to render something given the current state, and
// to call the ViewModel's methods in response to user action.
//
// Pros of this pattern:
// - ViewModel could be used with a custom view/component
// - ViewModel can be tested separately from the view/component
// - A component may consume multiple ViewModels to combine functionality
// - If there are breaking changes in the UI framework, or we need to migrate
//   to a different UI framework, there is far less code to change.
//
// To make this pattern work in Stencil, we need to do the following:
// - Load the ViewModel class (in case of core-adapter or async imports)
// - Create an instance of the ViewModel class
// - Setup two way binding between the props on the component and the props on
//   the view model
//
// Fortunately, a useAccessor controller exists that can do all of the above for
// you.

example("1. Doing two-way prop binding with an Accessor class", () => {
  // Create an Accessor class to serve as a viewModel for the component
  @subclass("MyViewModel")
  class MyViewModel extends Accessor {
    constructor(properties?: Partial<MyViewModelProps>) {
      super(properties);
    }

    @property()
    prop1: Nil | string;

    @property()
    prop2: Nil | number;

    combine(): string {
      return `${this.prop1 ?? ""} ${this.prop2 ?? ""}`;
    }
  }
  type MyViewModelProps = {
    readonly prop1: string;
    readonly prop2: number;
  };

  // Create a controller for the viewModel
  const useMyViewModel = makeAccessorController(MyViewModel);

  class ExampleComponent1 implements Use<typeof useMyViewModel> {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // Connect the viewModel to the component
    viewModel = useMyViewModel(this);

    // Do two-way binding of these Component's props to the viewModel
    @Prop() prop1 = this.viewModel.prop1;
    @State() prop2 = this.viewModel.prop2;

    // Can use reactiveUtils on the resulting Prop/State properties:
    reactiveUtils = load(importCoreReactiveUtils);
    componentWillLoad(): void {
      this.manager.onLifecycle(() =>
        this.reactiveUtils.watch(
          () => [this.prop1, this.prop2],
          (oldValue, newValue) => console.log({ oldValue, newValue }),
        ),
      );
    }

    // Can also access any member on the viewModel instance
    render(): string {
      return this.viewModel.combine();
    }
  }

  return ExampleComponent1;
});

example("2. Using viewModel from @arcgis/core", () => {
  // Similar binding works even for a viewModel coming from @arcgis/core-adapter:
  const useHomeViewModel = makeAccessorController(newWidgetsHomeHomeViewModel);

  class ExampleComponent2 implements Use<typeof useHomeViewModel> {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    viewModel = useHomeViewModel(this);

    @Prop() view = this.viewModel.view;
    @Prop() viewpoint = this.viewModel.viewpoint;
    @Prop() goToOverride = this.viewModel.goToOverride;

    reactiveUtils = load(importCoreReactiveUtils);
    componentWillLoad(): void {
      this.manager.onLifecycle(() =>
        this.reactiveUtils.watch(
          () => [this.view, this.viewpoint, this.goToOverride],
          (oldValue, newValue) => console.log({ oldValue, newValue }),
        ),
      );
    }
  }

  // The above works, but, to improve integration with @arcgis/core viewModels,
  // a special hook useViewModel has been build that goes beyond useAccessor
  // by also integrating with arcgis-map/scene, and doing event forwarding.
  // See it's documentation for more information:
  // https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/maxpatiiuk%2Fcontrollers/packages/map-components/src/controllers/useViewModel.md

  return ExampleComponent2;
});

example("3. Manually binding a prop to external store", () => {
  /**
   * If default two-way binding does not suit your use cases, you can bind
   * a property manually. This is useful if you wish to bind to a nested
   * property on your viewModel, or if you wish to bind to a global value
   */
  let someExternalStore = "initial value";

  class ExampleComponent3 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;
    @Prop() computed = this.manager.getSet(
      // Default value
      someExternalStore,
      {
        get: () => someExternalStore,
        set: (newValue) => {
          someExternalStore = newValue;
          // Trigger re-render
          forceUpdate(this);
          return someExternalStore;
        },
      },
    );
  }

  // Note, the above assumes that someExternalStore is only modified by this
  // component, and that there is only one instance of this component. Otherwise,
  // you would have to watch for when anyone modifies someExternalStore, and
  // call forceUpdate on each affected component.
  //
  // Of course, if you find youself doing this often, you may want to consider
  // writing a controller that would handle this for you, to reduce boilerplate
  // in each component

  return ExampleComponent3;
});
