/* eslint-disable @typescript-eslint/no-confusing-void-expression */
import type { VNode } from "@stencil/core";
import { Element, Prop, State, h, forceUpdate, Method, Component, Event } from "@stencil/core";
import type { ControllerManager, BaseComponent } from "../src";
import {
  makeGenericController,
  makeController,
  useControllerManager,
  load,
  Controller,
  usePropertyChange,
} from "../src";
import { example } from "./1.functional";
import { importCoreReactiveUtils } from "@arcgis/core-adapter";
import type { Nil } from "@arcgis/components-utils";

// Now that you have seen how functional and class-based controllers work, let's
// take a look at some of the exciting features controllers bring to Stencil:
// - reactiveUtils integration
// - get/set support
// - dynamic watchers
// - readonly properties
// - sync methods
// - and more!

example("1. ControllerManager is a controller too", () => {
  // Behind the scenes, ControllerManager is an instance of Controller class too!
  // This means, all the methods we shown before are available on
  // ControllerManager. This is primarily useful when Component needs to
  // dynamically register a lifecycle method, or use get/set/dynamic
  // watchers - more on that in a bit ðŸ™‚

  const useExample = (): string => makeController(async () => await Promise.resolve("Ixian Probe"));
  class ExampleComponent1 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;
    constructor() {
      // We can dynamically register lifecycle methods:
      this.manager.onLifecycle(() => {
        console.log("connected!");
        return (): void => console.log("disconnected!");
      });
    }

    example = useExample();

    // You can also add controllers on the fly:
    async componentWillLoad(): Promise<void> {
      const example = await this.manager.use(useExample());
      console.log(example); // 'Ixian Probe'

      // Note, controllers assigned to a property are automatically loaded before
      // the componentWillLoad callback on the Component is called, thus you
      // don't need to await it like that beforehand:
      // await this.manager.use(this.example);
      console.log(this.example); // 'Ixian Probe'
    }
    // For performance reasons, if you wish to start execution of your
    // componentWillLoad code before controllers are loaded, you can call
    // this.manager.onLoad(async ()=>{ /* some async code */ })
    // in your component constructor - such callback automatically wait for all
    // controllers to load beforehand, so you would need to call this.manager.use
    // manually
  }

  return ExampleComponent1;
});

example("2. reactiveUtils integration âœ…", () => {
  // Controllers add reactiveUtils integration to all Props and States on your
  // component, without the need for `extends Accessor`, or usage of
  // `@subclass()`/`@property()` decorators (since those are not available in
  // Stencil, and can't be used synchronously due to core-adapter's limitations).

  class ExampleComponent2 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    reactiveUtils = load(importCoreReactiveUtils);

    @State() a = 0;
    @Prop() b = 0;

    componentWillLoad(): void {
      this.manager.onLifecycle(() =>
        this.reactiveUtils.watch(
          () => [this.a, this.b],
          (oldValue, newValue) => console.log({ oldValue, newValue }),
        ),
      );
    }
  }

  return [ExampleComponent2];
});

example("3. Setters âœ…", () => {
  // While stencil supports get/set syntax for internal component properties,
  // for properties with @State() or @Prop() decorators, that is not possible.
  //
  // Fortunately, controllers lift this limitation:

  const minSize = 4;
  const maxSize = 10;
  class ExampleComponent3 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    @Prop() size = this.manager.getSet(minSize, {
      // Unlike regular JavaScript's setter, the setter is called both with the
      // new and the old attribute value.
      set: (newValue, oldValue) => {
        // To undo the change, and prevent re-render, simply return the old value
        if (newValue === 0) {
          return oldValue;
        }
        // Or, you can return a completely different value
        if (newValue < minSize) {
          return minSize;
        }
        // You can throw an error to both prevent the change, and communicate to
        // the user that they did something wrong:
        if (newValue > maxSize) {
          throw new Error("This is way too big!");
        }
        // Or you can return the new value as is:
        else {
          return newValue;
        }
      },
    });

    // If default value is set by the user in the DOM before your component is even
    // loaded, getSet will call your setter on that default value if there is any.
    // getSet will call your setter after the component constructor, right before
    // connected callback. This is to make sure that the DOM default is also
    // validated/casted/kept in sync with the external store you may be using.
    //
    // If your setter relies on some controller that might not yet be loaded by
    // then, you can either add a manual guard against this, or disable this
    // behavior by passing initialSet:false to getSet:
    @Prop() size2 = this.manager.getSet(0, {
      initialSet: false,
      set(newValue) {
        console.log(newValue);
        return newValue;
      },
    });

    onClick(): void {
      this.size = Math.random() * maxSize;
    }
  }

  // Setters are really useful for the following:
  // - validating a property BEFORE it's set
  // - casting/auto-casting a property to a different type
  // - calling an external setter
  //   - for example, mapping components call the ViewModel's setter, which may
  //     validate, cast or further modify the value. Then, the value set by
  //     ViewModel's setter is used to set the property on the component.
  //
  // Getters/Setters are also used by ControllerManager to implement
  // reactiveUtils integration

  return ExampleComponent3;
});

example("4. Getters âœ…", () => {
  // Getters are also available:
  class ExampleComponent4 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    getCount = 0;
    @Prop() counter = this.manager.getSet(
      // This is the default value. It will be used only if the attribute wasn't
      // already set in the DOM before the component was connected:
      0,
      {
        // Unlike regular JavaScript's getter, the getter is called with the
        // currently attribute value. It can choose to do something and return it,
        // or return a completely different value:
        get: (value) => {
          this.getCount += 1;
          console.log(this.getCount);
          return value;
        },
        // If you don't provide a setter, default Stencil behavior will be used.
        // If you wish to make a readonly prop, keep reading, and you will see
        // how to!
      },
    );

    render(): VNode {
      return <p>Count: {this.getCount}</p>;
    }
  }

  // If your getter returns a value other than the current prop value, you
  // got yourself a computed property! Example usages for computed properties:
  // - format a value before you return it to the user
  // - do lazy initialization/lazy computation only when the prop is accessed
  // - do some form of access control/sanitization

  return ExampleComponent4;
});

example("5. You may not need @State()", () => {
  // this.manager.getSet works for @State() properties too, although it's less
  // useful there as you can make do without it by using native get/set with
  // forceUpdate rather than the @State() decorator:

  class ExampleComponent5 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // You can mimic @State() with get/set and forceUpdate:
    private _count = 0;
    get count(): number {
      return this._count;
    }
    set count(newCount) {
      const isChanged = newCount !== this._count;
      this._count = newCount;
      if (isChanged) {
        forceUpdate(this);
      }
    }
    // The above is more performant, and flexible than using @State().
    //
    // Two things to note:
    // - such properties, unlike @State or @Prop properties will be reset to
    //   their defaults when Stencil does hot-reload (@State and @Prop values
    //   are preserved on HOT reload)
    // - you can't use @Watch() or dynamic watch (more on that in a bit) if your
    //   property is not a @State() or @Prop() property
  }

  return ExampleComponent5;
});

example("6. Dynamic get/set", () => {
  // In the spirit of reducing code duplication, if you need getters/setter for
  // a common set of properties between components, you can define your
  // getter/setter dynamically outside your component (i.e in a controller)
  // using dynamicGetSet:

  const useCountAccessor = makeGenericController<void, { count: number }>((_component, controller) => {
    controller.dynamicGetSet(
      // This is the property name, not the default value (default value is
      // presumably already set by this point):
      "count",
      {
        get: (value) => {
          console.log("get", value);
          return value;
        },
        set: (newValue, oldValue) => {
          console.log("set", newValue, oldValue);
          return newValue;
        },
      },
      // You can only use dynamicGetSet on properties that have @Prop() and
      // @State() decorators because, for regular properties, you can make do with
      // Object.defineProperty. But this restriction may be lifted in the future
      // if so desired
    );

    // Behind the scenes, getSet is using dynamicGetSet, so their behavior is
    // quite similar
  });

  class ExampleComponent6 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    @Prop() count = 0;

    // While it's a bit overkill in this case, if your controller sets several
    // getter/setters at once, this can be really useful:
    countAccessor = useCountAccessor(this);

    // makeViewModelController uses this to set getters/setters for all properties
    // that are supposed to stay in sync with the viewModel
  }

  // Note, besides dynamicGetSet, there is also genericGetSet that is a less
  // type-safe variant for cases when property names and types are not known
  // ahead of time.

  return ExampleComponent6;
});

example("7. readonly properties âœ…", () => {
  // With the power of getSet, you can add "readonly" props to Stencil.
  //
  // Since this may be needed commonly, there is a "readonly" method that is a
  // convenient shorthand for that.

  class ExampleComponent7 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // Reassigning this property or attribute will throw an error:
    @Prop({ reflect: true }) count = this.manager.readonly(0);

    onSecretClick(): void {
      // If you need to update the value of a read-only property internally, you
      // can do so inside of a bypassReadonly() callback:
      this.manager.bypassReadonly(() => {
        // Will bypass any custom setter we set, including that set using getSet
        // or dynamicGetSet
        this.count += 1;
      });

      // Note, unlike with native get/set, getSet's or readonly's setter is not
      // called if value did not change, thus, this will simply not do anything,
      // rather than throw an error:
      this.count = (this.count * 2) / 2;
      // Reasons:
      // - This matches the behavior of Stencil's watchers
      // - This is needed for @Prop({reflect:true}) to work as, for such props,
      //   Stencil will call the setter with the same value as the getter
      //   during render
    }
  }

  // Readonly props are especially useful until Custom State proposal for web
  // components is implemented:
  // https://developer.mozilla.org/en-US/docs/Web/API/CustomStateSet

  return ExampleComponent7;
});

example("8. sync methods", () => {
  // Stencil's forces @Method() function to be async. This is to allow for
  // calling component's methods while they are still loading
  //
  // However, in some cases that limitation is too restrictive. If you are
  // are confident your method won't be called before component is loaded, you
  // can create a sync method using a readonly prop:
  class ExampleComponent8 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    @Prop() syncMethod = this.manager.readonly((arg: string) => {
      console.log(arg);
      return "Hi sync world!";
    });
    // Now, the consumer of the component can call syncMethod and get the result
    // synchronously

    // And you can still call it inside the component too:
    onClick(): void {
      this.syncMethod("Hello sync world!");
    }
  }

  // You should avoid this pattern if you can for public-facing components as it
  // won't work when calling the method before component is loaded (in lazy ESM
  // builds). However, it can be quite useful in some cases, especially for
  // internal sub-components.

  return ExampleComponent8;
});

example("9. Using dynamic watchers", () => {
  // Stencil's compiler only allow setting watchers using the @Watch decorator.
  // However, this is very limiting as you can't set watchers dynamically,
  // leading to lots of boilerplate. Some properties are common between
  // components, so extracting their watchers into a single controller can be
  // very useful.

  class ExampleComponent9 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    @State() a = 0;
    @Prop() b = 0;

    constructor() {
      // Dynamically set a watchers for a and b
      const props = ["a", "b"] as const;
      props.forEach((prop) =>
        this.manager.watch(prop, (newValue, oldValue) => {
          console.log(prop, newValue, oldValue);
        }),
      );
    }
  }

  // And this is how moving those watchers out of the component looks like:
  const useWatcher = makeGenericController<void, { a: number; b: number }>((_component, controller) => {
    // Dynamically set a watchers for a and b
    const props = ["a", "b"] as const;
    props.forEach((prop) => {
      controller.watch(prop, (newValue, oldValue) => {
        console.log(prop, newValue, oldValue);
      });
    });
  });

  class ExampleComponent9a implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    @State() a = 0;
    @Prop() b = 0;
    watcher = useWatcher(this);
  }
  // This is awesome for code deduplication if you have several common properties
  // between components.
  //
  // You can set several watchers on the same property, and behind the scenes
  // they work exactly like Stencil's @Watch decorator.
  //
  // Note, since Controllers also add reactiveUtils integration, feel free to
  // use that to watch your properties. The only drawback of using reactiveUtils
  // is that you have to wait for them to load (due to core-adapter promise), so
  // can't use them in the constructor/connectedCallback (you can use them in
  // componentWillLoad though). In such cases, dynamic watcher is useful.

  return [ExampleComponent9, ExampleComponent9a];
});

example("10. Notifying the user of prop changes", () => {
  // If user of your component needs to be notified when a property on our
  // component changes, events are recommended way to go about it as they
  // play nicely with other HTML elements and web component libraries.
  //
  // To make emitting events require less boilerplate from the component author,
  // a usePropertyChange() controller was developed:
  //
  // Let's see how that looks like:

  @Component({ tag: "example-component-10" })
  class ExampleComponent10 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    @Prop() prop: Nil | string;
    @Prop() prop2: Nil | number;

    @Method()
    reset(): void {
      this.prop = null;
      this.prop2 = null;
    }

    @Event({ cancelable: true }) arcgisPropertyChange = usePropertyChange<this>()("prop", "prop2");
  }

  // Now, in JSX, your component can be used like this:
  // <example-component-10
  //   prop="value"
  //   onarcgisPropertyChange={({detail, target}) =>
  //     console.log(detail.name, target[detail.name])
  //   }
  // />
  //
  // Only the property names you provided to usePropertyChange will be watchable.
  // Generally, if a prop can be modified by your component, OR by a user
  // interacting with your component, you should emit an event for it.
  // Otherwise, if a prop is only modifiable in
  //
  // This also gives you flexibility to make some properties of your component
  // "unwatchable" (for type-purposes only)

  // Besides the events, there are other options for notifying the user of prop
  // changes:
  // - Using mutation observer
  //   - but, their syntax is verbose (unleash we provide a convenient wrapper),
  //     and they can't be used in JSX directly
  //   - plus, mutation observer only works on Props that are reflected back to
  //     HTML, which is not possible for all prop types, and has performance
  //     implications
  // - Using reactiveUtils
  //   - this is a great option internally, but may be too complex for a novice
  //     user, as it can't be set simple as a JSX prop
  //   - plus, it is a bit against the grain of common web components (won't
  //     work with other web component libraries as they don't support
  //     reactiveUtils)

  return ExampleComponent10;
});

example("11. Under the hood: tracking property names", () => {
  // ControllerManager has trackPropertyKey and trackPropKey helper utilities for
  // figuring out what is the property name for which a given function was called
  // when it is called in the default value.
  //
  // This is used by proxyExports() behind the scenes to figure out what property
  // it was assigned to. It is also used by .getSet() and .readonly() to figure out
  // what @Prop()/@State() they were assigned to.
  //
  // This is really cool as it removes the need for the user to explicitly pass
  // the property name, which could be quite bug prone (might not match the actual
  // property name or get out of date on refactoring)

  // Here is a small controller that shows how trackPropertyKey and trackPropKey utils can
  // be used

  class Logger extends Controller {
    // Track key for a property that does not have a @Prop() or @State() decorator:
    logKey<T>(defaultValue: T): T {
      this.component.manager.trackPropertyKey(
        // Track what property was set to the default value on the component.
        // Note, if you need to support nested controllers, you may need to pass
        // nested controller instance here. See implementation of proxyExports()
        // for an example of that
        this.component,
        (key) => {
          // "key" would be undefined only if logKey() was used not in a default
          // value, or not on the component (unless you support usage on nested
          // controller usages too)
          if (key === undefined) {
            console.error(
              "Unable to resolve prop name. Did you assign logger.trackPropertyKey() as a default value for a property on a component?",
            );
          } else {
            console.log(`Property "${key}" was set to ${String(defaultValue)}`);
          }
        },
        defaultValue,
      );
      return defaultValue;
    }

    // The way logKey() works is pretty simple! It calls Object.keys() initially,
    // and does so again on queueMicrotask(), and checks what is the name of the
    // property that was added immediately after the last call to Object.keys().
    // For extra safety, it also compares that the value of that newly added
    // property matches what default value it is supposed to have.

    // Track key for a property that has @Prop() or @State() decorator:
    logPropKey<T>(defaultValue: T): T {
      // trackPropKey only makes sense on the component itself, since controllers
      // don't have their own @Props(), so you don't have to explicitly pass in
      // the component:
      this.component.manager.trackPropKey((key) => {
        if (key === undefined) {
          console.error(
            "Unable to resolve prop name. Did you assign logger.trackPropertyKey() as a default value for a @State()/@Prop() property?",
          );
        } else {
          console.log(`Property "${key}" was set to ${String(defaultValue)}`);
        }
      }, defaultValue);
      return defaultValue;
    }
    // Unlike trackPropertyKey, trackPropKey works using dynamicGetSet behind the scenes.
    // While regular properties are defined on the component instance, Stencil
    // defines @Prop() and @State() properties on the component's prototype, and
    // it uses getter/setters to prevent the property from being set on the
    // instance. This prevents the Object.keys() trick from working, but we can
    // listen to setters for all @Prop() or @State() properties to see which one
    // was called was called, and from there know what property name was
    // assigned to the default value.
    //
    // If you are not sure whether your function will be called as a default on
    // property or Prop/State, you can call both trackPropertyKey and trackPropKey and
    // see which resolves the value (the other one is guaranteed to resolve to
    // undefined)
  }

  // Now, here is how the above logger can be used:
  class ExampleComponent11 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    logger = new Logger();
    // Will log "Property "property" was set to Fremen"
    property = this.logger.logKey("Fremen");

    // Will log "Property "prop" was set to Gom jabbar"
    @Prop() prop = this.logger.logPropKey("Gom jabbar");
    // Will log "Property "state" was set to Harvester"
    @State() state = this.logger.logPropKey("Harvester");
  }

  // makeViewModelController uses trackPropKey too to power it's two way prop
  // binding (bind viewModel properties to the component's properties).

  return ExampleComponent11;
});

/*** The end ***/

// Next, take a look at ./4.accessor.md to see how Controllers help you
// integrate with JS API's Accessor and reactiveUtils

// Have feedback, questions or need help?
// Make a post in this GitHub Discussion:
// https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/711

/* eslint-enable @typescript-eslint/no-confusing-void-expression */
