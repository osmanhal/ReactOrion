# Future Plans for Controllers

## General

Aim for simple-looking API that is also simple to explain

- FIXME: add controller tests for usage with Lit

- REFACTOR: make useViewModel documentation more discoverable

- TEST: useViewModel, useWidget, trackKey

- TEST: does "number | Nil" properly casts "2" to 2?

- FINAL: test controllers for memory leaks

- FINAL: run performance profiler

- REFACTOR: replace root <div> with <Host> in home

- FEATURE: add TODO in migration to replace root <div> with <Host>

- FEATURE: implement useDarkMode() controller

## Stencil

TODOs specific to Stencil and that aren't needed with Lit

- FIXME: add resolveId external plugin for controllers and utils

- REFACTOR: remove Stencil-specific logic in the future (and remove 3.stencil.tsx, but prioritize 6.lit.tsx)

- TEST: investigate Stencil's e2e test and add utils for them too

- TEST: add automated tests for the different output targets

- FEATURE: investigate dynamic @Listen support

- LOW: try out Stencil Compiler API with custom file system - https://stenciljs.com/docs/compiler-api

- LOW: Explore context API, inspired by https://lit.dev/docs/data/context/ and https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md. We might even be able to use @lit/context with Stencil Controllers!

### Improve Accessor integration

With get/set support, integrating Accessor with Stencil components becomes much
more feasible.

Though, Stencil does not support support custom decorators yet, adding their
support should be doable

- FEATURE: try out adding decorator support (currently get `ReferenceError: __decorate is not defined` error)

  - Test if decorators work fine on methods though?

- REFACTOR: replace @State() with a custom decorator/function?

- FEATURE: Track accessor reads in `render()` and trigger re-render on change:

  ```ts
  const originalRender = this._component.render.bind(this._component);
  let lastResult = undefined;
  let hadFirstRender = false;
  this._component.reactiveUtils.watch(originalRender, (newResult) => {
    if (!this._component.el.isConnected || !hadFirstRender) return;
    lastResult = newResult;
    this._component.requestUpdate();
  });
  this._component.render = () => {
    hadFirstRender = true;
    if (lastResult !== undefined) {
      const render = lastResult;
      lastResult = undefined;
      return render;
    }
    return originalRender();
  };
  ```

  - If we expose some accessor's internal members (like runTracked an
    TrackingTarget), this would be more production ready. However, the fact that
    core-adapter imports must be async is problematic as we can't extend
    Accessor class.

## Make core-adapter less painful to use

Core adapter is a bit painful to use because it forces async imports for
everything and because that doesn't work well with auto-import.

Hugo Campos had a great idea of using regular ESM imports for @arcgis/core, but
having a build-time plugin that would convert those to async imports or
something else that servers the role of core-adapter

See https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/709

## The End

This is it for Controllers documentation. Now, take a look at some
[real-world controllers](./README.md#real-world-examples) and go build something
cool using Controllers!
