# Controllers

## What it is

A pattern for efficient code reuse in Stencil components, given the limitations
of the Stencil compiler, the need for strong type safety, and the requirements
for compatibility with JS API's concepts like viewModel, Accessor and core
adapter.

## Why it's needed

Code reuse between Stencil components is complicated because Stencil does not
support get/set, class inheritance, mixins and decorators.

These features are used a lot in JS API's Widgets for code reuse, validation,
deprecation notices, making props readonly and other things - alternative
patterns have to be discovered in Stencil.

We heard from the Stencil team that supporting these features is not a priority
for them, so alternative options are explored.

Controllers aim to address all these concerns - they allow for effective code
reuse between Stencil components, while being very type-safe. They are like
react hooks, but tie into the Stencil component lifecycle.

### Context Knowledge

- Map Components will be gradually replacing JS API widgets, while
  maintaining compatibility with existing viewModels.
  - That means, attributes on the component should be kept in two-way sync with
    properties on the view model. And view-model emitted events should be
    re-emitted on the component.
  - In addition to reducing migration burden, this would reduce the need for
    consumers to directly access viewModel, thus keeping them within web
    components paradigm.
  - Beyond Map Components, other teams benefitted from the viewModel pattern too.
    Accessor-based ViewModels reduce Esri's exposure to underlying rendering
    framework (be it Maquette, Stencil, or something else in the future), making
    migration easier.
- Because of the need to support both ESM and CJS in a single build, a
  core-adapter was created that manages loading JS API modules. As a side
  effect, all imports of core api must be async, which complicates the code.

### Installation

Recommended prerequisite: [Learn the basics of Stencil](https://stenciljs.com/docs/introduction)

Add the following to your Stencil Config:

```ts
import type { Config } from "@stencil/core";
import { useComponentsControllers } from "@arcgis/components-controllers/dist/plugins";
import {
  makeCalciteExternal,
  makeArcgisExternal,
  refreshT9NTypes,
  betterDocsJson
} from "@arcgis/components-plugins";
import path from "node:path";

export const config: Config = {
  // ...
  outputTargets: [
    // ...
    // This is like docs-json output target, but it removes non-literal values
    // from the default values in docs.json so as not to expose internal
    // source code
    ...betterDocsJson({ file: "./.docs/docs.json" }),
  ],
  rollupPlugins: {
    before: [
      // Add support for Controllers in Stencil Web Components:
      useComponentsControllers(),
      // Not required by controllers, but likely needed in your project:
      makeArcgisExternal()
      makeCalciteExternal(),
      refreshT9NTypes()
      // See https://qawebgis.esri.com/arcgis-components/?path=/docs/references-stencil-development-framework--docs#stencil-build-configuration
    ]
  },
  testing: {
    transform: {
      // Add support for Controllers and core-adapter in Stencil's Jest tests:
      preset: require.resolve("@arcgis/components-controllers/jest-preset"),
    }
  }
  // ...
};
```

<details>
<summary>Why is Rollup Plugin and Stencil Transformer necessary?</summary>

Each component that is using Controllers forwards all lifecycle hooks to the
controller manager:

```tsx
// Just an example. Actual code differs.
connectedCallback(): void {
  this.manager.hostConnected();
}
disconnectedCallback(): void {
  this.manager.hostDisconnected();
}
async componentWillLoad(): Promise<void> {
  await this.manager.hostLoad();
}
componentDidLoad(): void {
  this.manager.hostLoaded();
}
async componentWillUpdate(): Promise<void> {
  await this.manager.hostUpdate();
}
componentDidUpdate(): void {
  this.manager.hostUpdated();
}
```

> note, the above members must be methods, not arrow functions, because Stencil
> Compiler parses the AST looking for methods

Since component is giving all control over the lifecycle to the controller, and
the controller is the code we control, we can add any logic we want, and make
changes, without being constrained by the Stencil Compiler.

Since the above members are the same for every component that uses controller,
a build-time Rollup plugin was developed that automatically adds the above code
to any Stencil component that uses controller. This reduces boilerplate
considerably.

If component needs to use lifecycle hooks, it can define them like it normally
does, and the plugin will merge the code automatically. Component is also
encouraged to encapsulate it's lifecycle logic into a controller, reducing the
readability issue of having a large component do many things. This is similar to
the best practices around custom React hooks.

---

Besides that, the plugin allows Controller to set dynamic watchers, as well as
adds get/set support in Stencil.

---

Additionally, while Rollup plugins are run during development, production, and
end-to-end tests, Rollup is not used by Stencil during unit tests. To correctly
support controllers in those, a small Jest transformer is necessary.

</details>

<details>

### How it's used

Picking an `arcgis-home` from map components as an example:

```tsx
const useHomeViewModel = makeViewModelController(newWidgetsHomeHomeViewModel);
export class Home implements Use<typeof useHomeViewModel> {
  manager: ControllerManager<this> = useControllerManager(this);
  reactiveUtils = load(importCoreReactiveUtils);
  viewModel = useHomeViewModel(this);
  disconnect = useHandles("disconnect");
  messages = useT9n<HomeStrings>();

  @Prop() viewpoint = this.viewModel.viewpoint;
}
```

`useControllerManager(this)` is the one that binds all controllers together to Stencil
lifecycle hooks.

`load(...)` is a controller that wraps core-adapter in a way that it can be used
within the component without having to deal with promises.

`const useHomeViewModel = makeViewModelController(newWidgetsHomeHomeViewModel)`
and later `viewModel = useHomeViewModel(this)` loads a given view model, and
does two way binding between props on the component and view model properties,
as well as re-emits viewModel's events on the component.

Accessing `this.viewModel.viewpoint` sets up a two-way binding between the
viewModel and the component for a given property. It also removes the need for
explicitly specifying prop type, as type is received from the viewModel prop
type.

With the above configuration, you can now use the following in your component:

```tsx
  componentWillLoad() {
    this.disconnect.addHandles(
      this.reactiveUtils.watch(
        ()=>this.viewpoint,
        (viewpoint) => console.log('viewpoint changed', viewpoint);
      )
    )
  }
```

You might have noticed that we didn't add `extend Accessor` or call Accessor
decorators like `@subclass`/`@property`, yet reactiveUtils works just fine.
Controller Manager adds `reactiveUtils` integration in a way that is compatible
with the Stencil Compiler.

## Benefits of Controllers

See how much of a difference Controllers make by comparing these
[3 implementations of the `arcgis-home` component](https://devtopia.esri.com/WebGIS/arcgis-web-components/tree/maxpatiiuk/controllers-example/packages/map-components/src/components/home#readme).

- A component that just wraps a JS API widget is **93** lines of code.
- Implementing
  the component natively without Controllers is **159** lines of code.
- Using
  controllers, same work can be done in just **63** lines of code ðŸ¥³.

That's right,
implementing the component with Controllers takes less code than just wrapping
the JS API widget!

Less code is not the only benefit of Controllers. See the full list:

- Extract away business logic, especially if it's related to Stencil's
  lifecycle.
  - This also makes it easy to test business logic in isolation from the component
  - Deduplicate code between components
- Adds `Accessor` and `reactiveUtils` integration to Stencil
- Adds get/set support to Stencil, readonly properties, sync methods, and the
  ability to set dynamic watchers.
- Controllers await promises behind the scenes, letting you write code that
  treats promises as if they are already resolved
- Catch & prevent bugs, thanks to strong type-safety, and "pit-of-success"
  design of controllers.
- Provide an optional `destroy()` lifecycle method for destructor logic that
  must be done only once (web components have a `disconnectedCallback` but it
  can be called several times, each time component is disconnected after being
  re-connected)

## How Controllers are Defined & Example Usages

To learn how to use Controllers, and to see all of their powerful capabilities,
take a look at the [progressive Controllers tutorial](./1.functional.tsx).

Have feedback, questions or need help? [Make a post in this GitHub Discussion](https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/711).

## TypeScript type checking and safety

By providing "this" to a controller, it can check that the class contains all
required members. For example, `viewModel` checks that each view model prop is
present on the component, and otherwise emits a type error.

```ts
  // HomeViewModel has "goToOverride" property.
  // useHomeViewModel(this) ensures you have it defined on the component.
  // this.viewModel.prop adds two-way binding between Stencil's prop and
  // viewModel's property
  @Prop() goToOverride = this.viewModel.goToOverride
```

You may have noticed that the component above has this declaration:

```ts
export class Home implements Use<typeof useHomeViewModel> {
  /* ... */
}
```

The `implements Use<typeof useHomeViewModel>` in class
definition is completely optional - TypeScript catches all errors even without
it. It's only needed to improve DX (it makes error messages better).

Controllers can also require another controller to be present on the component,
and emit a TypeScript error otherwise

### disconnectedCallback vs destroy()

JS API Widgets were build with a `destroy()` method in mind, and the idea that
once something is destroyed, it's not supposed to be used again. Web Components
don't have a `destroy()` method. They have a `disconnectedCallback`, which is
called when the component is removed from the DOM - but, it could be reconnected
back at any point.

A lot of component cleanup logic should only be done once, rather than
on each disconnect. Also, existing JS API's Widgets were build with that in
mind. A permanent `destroy()` is necessary in such cases.

If your component needs `destroy()` callback, you can opt-in like this
(it is optional):

```ts
/**
 * If true, the component will not be destroyed automatically when it is
 * disconnected from the document. This is useful when you want to move the
 * component to a different place on the page, or temporary hide it. If this
 * is set, make sure to call the \`destroy\` method when you are done to prevent
 * memory leaks.
 */
@Prop() autoDestroyDisabled = false;

/** Permanently destroy the component */
@Method()
async destroy(): Promise<void> {
  await this.manager.destroy();
}
```

If disconnect happens, and `autoDestroyDisabled` is `false` (which is the
default), destroy is called automatically. Otherwise, it's user's responsibility
to manually call destroy when appropriate to avoid memory leaks.

If you do not define the above, but try to use a controller with `destroy()`
lifecycle event, you will receive an error with helpful instructions.

## Examples

To learn how to use Controllers, and to see all of their powerful capabilities,
take a look at the [progressive Controllers tutorial](./1.functional.tsx).

Have feedback, questions or need help? [Make a post in this GitHub Discussion](https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/711).
