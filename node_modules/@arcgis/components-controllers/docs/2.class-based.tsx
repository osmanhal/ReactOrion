import type { VNode } from "@stencil/core";
import { Element, h } from "@stencil/core";
import type { ControllerManager, BaseComponent } from "../src";
import { makeController, useControllerManager, proxyExports, Controller, GenericController, toFunction } from "../src";
import { example } from "./1.functional";

// Defining controllers using makeController()/makeGenericController() is the simplest
// and most concise way. However, if you are more comfortable with classes, or
// wish to use more advanced features, you can define your controller using a
// class
//
// Some of the features class-based controllers offer:
// - Can use extends/mixins/abstract classes/static members/getters/setters and
//   decorators for advanced code reuse
// - Using methods is more efficient than dynamically creating functions inside
//   the controller thanks to method instances being shared on the prototype
// - Can expose the entire controller instance to the component, rather than
//   just it's exports (more on this in Example 1)

example("1. Class-based controller ✅", () => {
  // Create a Controller class ("extends Controller" is what makes it special)
  class GreeterController extends Controller {
    constructor(private _name: string) {
      super();
    }
    sayHi(): void {
      console.log(`Hi ${this._name}!`);
    }
  }

  // and later usage:
  class ExampleComponent1 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    controller = new GreeterController("Bene Tleilax");
    onClick(): void {
      // Will print "Hi Bene Tleilax!"
      this.controller.sayHi();
    }
  }

  return ExampleComponent1;
});

example("2. Lifecycle ✅", () => {
  class LogLifecycle extends Controller {
    constructor() {
      super();
      console.log("This is called during component construction");
      console.log("Component reference: ", this.component);
    }
    hostConnected(): void {
      console.log("connectedCallback");
    }
    hostDisconnected(): void {
      console.log("disconnectedCallback");
    }
    // This method could also be async
    hostLoad(): void {
      console.log("componentWillLoad");
    }
    hostLoaded(): void {
      console.log("componentDidLoad");
    }
    hostUpdate(): void {
      console.log("componentWillUpdate");
    }
    hostUpdated(): void {
      console.log("componentDidUpdate");
    }
    hostLifecycle(): () => void {
      console.log("called on first load and on each subsequent connectedCallback");
      return (): void => {
        console.log("called on each disconnectedCallback");
      };
    }
  }
  // and later usage:
  class ExampleComponent2 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    logger = new LogLifecycle();
  }

  return ExampleComponent2;
});

example("3. Similarities to functional controllers", () => {
  // Behind the scenes, makeController()/makeGenericController() are defined as a
  // class-based controller. That is why, there is a lot of similarities in
  // behavior between them.
  //
  // To tell you a secret, the 2nd argument in makeController() constructor,
  // "controller", is actually an instance of a Controller class! Which means, all
  // of the same methods we used before are available in class-based controllers
  // as well:
  class DynamicLifycycle extends Controller {
    constructor() {
      super();

      if (Math.random() > 1 / 2) {
        this.onConnected(() => {
          console.log("dynamically register a lifecycle method!");
        });
      }
    }
  }
  // and later usage:
  class ExampleComponent3 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    dynamicLifecycle = new DynamicLifycycle();
  }

  return ExampleComponent3;
});

example("4. A controller that expects certain properties to be on the component", () => {
  // Similarly to functional controllers, you can use GenericController class
  // rather than Controller when your controller expects certain properties to be
  // present on the component

  type Requires = { name: string };
  // First type argument is the type of the exports - we don't export anything,
  // so it's "void". Second type argument is what we require on the component:
  class ExpectantController extends GenericController<void, Requires> {
    constructor(component: BaseComponent & Requires) {
      super(component);
      console.log(`Hi ${this.component.name}!`);
    }
  }

  // If your controller does not need a constructor, typing can be a bit
  // simplified:
  class ExpectantController2 extends GenericController<void, Requires> {
    hostConnected(): void {
      console.log(`Hi ${this.component.name}!`);
    }
  }

  // and later usage:
  class ExampleComponent4 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    name = "Face Dancer";

    // Will console log "Hi Face Dancer!" in the constructor
    expectant = new ExpectantController(this);
    // Will console log "Hi Face Dancer!" during connectedCallback
    expectant2 = new ExpectantController2(this);
  }

  // Note, unlike with functional controllers, due to limitations of TypeScript,
  // the Use<typeof controller> trick is not available in the "implements"
  // section of your controller.
  // "An interface can only extend an object type or intersection of object types
  // with statically known members"
  //
  // Fortunately, several workarounds are available:

  // 1. Simply don't use Use as it's optional (it improves Developer experience
  //    if your controller expects a lot of properties, but not required for
  //    catching type-errors)

  // 2. Make your controller export a type and use it in your component:
  type ExpectantConsumer = BaseComponent & Requires;

  class ExampleComponent4a implements ExpectantConsumer {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;
    name = "Face Dancer";
    expectant = new ExpectantController(this);
  }
  // Or like this:
  class ExampleComponent4b implements BaseComponent, Requires {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;
    name = "Face Dancer";
    expectant = new ExpectantController(this);
  }

  // 3. Use proxyExports (see example 6)
  console.log(ex6);

  // 4. Wrap your controller constructor in a function (see example 8)
  console.log(ex8);

  return [ExampleComponent4, ExampleComponent4a, ExampleComponent4b];
});

example("5. Nested controllers", () => {
  // There are two ways to nest controllers:
  class ChildController extends Controller {
    constructor(private _log: string) {
      super();
    }

    hostConnected(): void {
      console.log(this._log);
    }

    sayHiTwice(): void {
      console.log("Hi!");
      console.log("Hi!");
    }
  }

  class ParentController1 extends Controller {
    // This is just like using any other class:
    child = new ChildController("I'm a child!");

    hostConnected(): void {
      this.child.sayHiTwice();
    }

    async hostLoad(): Promise<void> {
      // Or, if you only need a controller in a single place, you can declare it
      // inline and on the fly using useRef():
      const child = await this.useRef(new ChildController("I'm a child!"));
      // As a reminder, to get access to a controller instance, rather than just
      // controller's exports, you should use "useRef" instead of "use"

      child.sayHiTwice();
    }
  }

  // Functional and Class-based controllers are fully inter-compatible.
  // Here is how to use a functional controller inside a class-based controller:
  const functional = (log: string): string => makeController(() => log.toUpperCase());
  class ParentController2 extends Controller {
    logger = functional("I am a child!");

    async hostLoad(): Promise<void> {
      // Will console log "I AM A CHILD!"
      console.log(this.logger);

      // In case of functional controllers, you likely only care about the
      // controller exports, rather than the entire controller instance, thus we
      // can call "use" instead of "useRef"
      const result = await this.use(functional("I am a child!"));

      // Will console log "I AM A CHILD!"
      console.log(result);

      // If you did call useRef though, you can still access the exports using
      // the ".exports" property
      const controller = await this.useRef(functional("I am a child!"));
      console.log(controller.exports);
    }
  }

  class ExampleComponent5 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    parent1 = new ParentController1();
    parent2 = new ParentController2();
  }

  return ExampleComponent5;
});

const ex6 = example("6. Controller exports & proxyExports()", () => {
  // You may have noticed a difference between functional and class controllers,
  // where functional controllers only give you access to the exports, while class
  // controllers give you access to the entire controller instance.
  //
  // If you wish to use the class controller syntax, but wish to expose only the
  // controller exports, then wrap your controller class in a proxyExports()
  // function (which is exactly what functional controllers do behind the scenes)
  //
  // And to set controller exports, you can use the "exports" property

  // Provide a generic argument to Controller to define what is the type of our
  // exports (number in this case):
  class TimerController extends Controller<number> {
    constructor(private _timeout: number) {
      super();
      this.exports = 0;
    }
    hostLifecycle(): () => void {
      const timeout = setTimeout(() => {
        this.exports = Math.random();
      }, this._timeout);
      /*
       * FYI: checkout devToolsAwareTimeout() for a more developer-friendly
       * version of setTimeout
       */
      return () => clearTimeout(timeout);
    }
  }
  const timer = proxyExports(TimerController);

  // and later usage:
  const oneSecond = 1000;
  class ExampleComponent6 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // Return type of timer() is just a number, not Controller<number>
    timer = timer(oneSecond);
    // See how our controller constructor's arguments became the arguments of
    // the timer() function

    render(): VNode {
      // The cool part is that when timer controller updates it's exports, the
      // this.timer property in our component will update too! (no need to watch
      // exports). And similar to functional controllers, the component will
      // re-render when the exports change
      return <div>{this.timer}</div>;
    }
  }

  return ExampleComponent6;
});

example("7. More advanced proxyExports()", () => {
  class DoubleString extends Controller<string> {
    constructor(private _value = "a") {
      super();
      this.exports = _value;
    }
    hostConnected(): void {
      this.exports = `${this._value}${this._value}`;
    }
  }
  const double = proxyExports(DoubleString);

  // proxyExports() works even inside another controller:
  class MyController extends Controller {
    // The value of this.a will get updated automatically when double()'s exports changes
    a = double();
    b: string;
    constructor() {
      super();
      // The value of this.b will get updated automatically when double()'s exports changes
      this.b = double("b");
    }
  }

  class ExampleComponent7 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;
    // The value of this.a will get updated automatically when double()'s
    // exports changes
    a = double();

    // The value of this.controller.a and this.controller.b will also get updated,
    // triggering a re-render as needed
    controller = new MyController();
  }

  // NOTE:
  // For proxyExports to dynamically update it's exports on the host,
  // the host must either be a Component that uses useControllerManager() or a
  // class that extends Controller/GenericController. Also, the proxyExports
  // controller must be assigned as a default value for a property (either in
  // property declaration or in the constructor) of the host (rather than
  // reassigning a value of a previously assigned property)

  return ExampleComponent7;
});

const ex8 = example("8. Constructor wrappers", () => {
  // Even if you are not using proxyExports(), you may wish to create a wrapper
  // function for your controller constructor.
  class WrappedController extends Controller {
    constructor(public name: string) {
      super();
    }
    greet(): void {
      console.log(`Hi ${this.name}!`);
    }
  }
  const useWrapped = (name: string): WrappedController => new WrappedController(name);

  // A few reasons to do this:
  // - if your controller is GenericController, a wrapper function is usable
  //   with Use<> type helper
  // - wrappedController("Ghola"); is shorter than new WrappedController("Ghola");
  // - this can improve TypeScript typing sometimes, and fix a TypeScript error
  //   like this:
  //   'controller' implicitly has type 'any' because it does not have a type
  //   annotation and is referenced directly or indirectly in its own initialize

  // Given several uses for this pattern, a toFunction utility is provided
  // that accomplishes the same thing:
  const useWrapped2 = toFunction(WrappedController);

  // and later usage:
  class ExampleComponent8 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    wrapped = useWrapped("Ghola");
    wrapped2 = useWrapped2("Hunter-seeker");
    onClick(): void {
      this.wrapped.greet();
      this.wrapped2.greet();
    }
  }

  return ExampleComponent8;
});

example("9. TypeScript generics", () => {
  // Class-based controllers are also friendly with TypeScript's generics:
  class Generic<T extends string> extends Controller<string> {
    constructor(private _name: T) {
      super();
    }
    get doubleName(): [T, T] {
      return [this._name, this._name];
    }
  }

  // and later usage:
  class ExampleComponent9 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    generic = new Generic("Test");

    onClick(): void {
      // You can hover over doubleName and see that it's type is ["Test", "Test"]
      console.log(this.generic.doubleName);
    }
  }

  // Using generics in class-based controllers is actually simpler than in
  // functional controllers, as if your class has several methods, they don't need
  // to have type parameters passed in manually (all methods in a class can use
  // class' type parameters).
  // In comparison, with functional controllers you would either have to pass
  // type parameters to each function, or define all functions inside your
  // controller (which may be worse for memory usage and readability).

  return ExampleComponent9;
});

export const ex10 = example("10. Provisional exports", () => {
  // For more advanced controllers, you may wish to provide some limited exports
  // during component construction (for example, to allow usage in default values)
  // but wish to delay the full exports till after controller is fully loaded.
  //
  // There is a setProvisionalExports method that helps with that:

  type PartialExports = {
    double: (name: string) => string;
  };
  type Exports = PartialExports & {
    result: string;
  };
  class AsyncController extends Controller<Exports> {
    constructor() {
      super();
      this.setProvisionalExports({
        double: this.double,
      });
    }
    double = (value: string): string => `${value}${value}`;

    async hostLoad(): Promise<void> {
      const fullResult = await fetch("some url").then(
        async (response) => (await response.json()) as Omit<Exports, "double">,
      );

      this.exports = {
        double: this.double,
        ...fullResult,
      };
    }
  }
  const asyncController = proxyExports(AsyncController);

  class ExampleComponent10 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    controller = asyncController();

    // We can access limited exports during component construction
    myProp = this.controller.double("default");

    onClick(): void {
      // The rest is only available after the controller is fully loaded:
      console.log(this.controller.result);
    }

    // Trying to access any non-existent property on provisional exports will
    // throw an error:
    // "Trying to access "result" on the controller before it's loaded. ...etc"
    test = this.controller.result;
  }

  // Provisional exports are used by makeViewModelController() to allow declaring
  // controller<-->view model bindings, even before the view model is loaded,
  // while catching any incorrect usages of view model before it's loaded.

  return ExampleComponent10;
});

/*** The end ***/

// Next, take a look at ./3.stencil.tsx for cool extensions controllers bring
// to Stencil (get/set, dynamic watchers, readonly Props and more!)

// Have feedback, questions or need help?
// Make a post in this GitHub Discussion:
// https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/711
