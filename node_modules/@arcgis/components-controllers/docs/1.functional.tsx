/* eslint-disable @typescript-eslint/no-confusing-void-expression */
import { Element, Prop, Method } from "@stencil/core";
import type { ControllerManager, BaseComponent, Use } from "../src";
import { makeGenericController, makeController, useControllerManager, load, useHandles } from "../src";
import { ex10 } from "./2.class-based";
import { importCoreReactiveUtils } from "@arcgis/core-adapter";

// The simplest controllers can be created using the makeController() function.
// The examples below introduce you to basic controllers first, and then
// incrementally get more advanced.
//
// Examples marked with "âœ…" show important core concepts. Other examples provide
// more advanced usages for those who wish to dive deeper and get all the
// benefits.

example("1. A simple controller âœ…", () => {
  const helloController = (): { say: () => void } =>
    makeController((component) => {
      // Controller receives the reference to the component it's used in
      console.log(component);
      return {
        say: (): void => console.log("Hello world"),
      };
    });
  // and later usage:
  class ExampleComponent1 implements BaseComponent {
    // This is a controller manager, which must be present in all components
    // that use controllers - it connects controllers to Stencil's lifecycle
    // hooks
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // Initialize the controller
    hello = helloController();

    onClick(): void {
      // Controller returned a method, and we can use it inside our component
      this.hello.say();
    }
  }

  return ExampleComponent1;
});

example("2. A controller that requires parameters âœ…", () => {
  // The controller constructor could request arguments:
  const greetUser = (name: string): { greet: () => void } =>
    makeController((component) => {
      console.log(component);
      return {
        greet: (): void => console.log(`Hello ${name}`),
      };
    });

  // and later usage:
  class ExampleComponent2 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // Provide the arguments to the controller
    hello = greetUser("Ava");

    onClick(): void {
      this.hello.greet();
    }
  }

  return ExampleComponent2;
});

example("3. A controller that returns a promise âœ…", () => {
  const computeTheMeaningOfLife = (): string => makeController(async () => await Promise.resolve("42"));
  // and later usage:
  class ExampleComponent3 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    /*
     * If controller returns a promise, the promise will be fully resolved
     * during componentWillLoad() lifecycle hook
     */
    theUltimateAnswer = computeTheMeaningOfLife();

    render(): string {
      // The promise is already resolved by the time render() is called,
      // so it can be used without worrying about awaiting it:
      return `The answer is ${this.theUltimateAnswer}`;
    }
  }

  return ExampleComponent3;
});

example("4. A controller that hooks into component's lifecycle âœ…", () => {
  // See Stencil component lifecycle: https://stenciljs.com/docs/component-lifecycle

  const logLifecycles = (): void =>
    makeController((component, controller) => {
      // Functional Controllers are initialized in component's constructor,
      // before connectedCallback.

      console.log(component);

      controller.onConnected(() => console.log("connectedCallback"));
      // Note: this may be called more than once
      controller.onDisconnected(() => console.log("disconnectedCallback"));
      controller.onLoad(() => console.log("componentWillLoad"));
      controller.onLoaded(() => console.log("componentDidLoad"));
      controller.onUpdate(() => console.log("componentWillUpdate"));
      controller.onUpdated(() => console.log("componentDidUpdate"));

      // Not a Stencil hook, but something invented by Controllers for convenience:
      // controller.destroy(() => console.log("bye!"));
      // To use destroy() lifecycle event, your component must opt-in into it.
      // Go to Example 11, or use your IDE's "Go to definition" to see that example:
      console.log(ex11);
    });
  // and later usage:
  class ExampleComponent4 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    logger = logLifecycles();

    test(): void {
      // Note, since our controller didn't return anything, "this.logger" is undefined
      console.log(this.logger); // undefined
      // That is totally fine, and won't interfere with the controller's lifecycle
      // hooks.
    }
  }

  return ExampleComponent4;
});

example("5. Using reactiveUtils, handles and onLifecycle() âœ…", () => {
  // A useHandles() controller implements the following methods from the Accessor
  // API in ArcGIS Maps SDK for JavaScript:
  // addHandles - https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#addHandles
  // hasHandles - https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#hasHandles
  // removeHandles - https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#removeHandles
  // removeAllHandles - removes all handles
  //
  // Except, to adapt these to web-components, you have an option of picking
  // whether handles should get removed on component disconnect or destroy().
  //
  // destroy() is an opt-in lifecycle event provided by the controllers API.
  // Prefer using "disconnect" over "destroy" whenever possible
  class ExampleComponent5 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // Give a promise-returning function to load() controller, and it will make
    // sure to load your promise during componentWillLoad lifecycle hook
    // This is a perfect use case for core-adapter's async import functions:
    reactiveUtils = load(importCoreReactiveUtils);
    // Create a handle manager that removes the handles on destroy()
    destructor = useHandles("destroy");

    @Prop() label = "a";

    // Note, the following code has several issues:
    // 1. Connected callback could be called multiple times, creating a duplicate
    //    watch listener each time (but in this case, we only cleanup the
    //    handles on destroy() rather than disconnect)
    connectedCallback(): void {
      // 2. It is a web component best practice to avoid destroy(), and to use
      //    disconnect instead, thus this should be refactored to listen to
      //    disconnect instead of destroy():
      this.destructor.addHandles(
        // 3. reactiveUtils may not yet be loaded here - we must await it first
        this.reactiveUtils.watch(
          () => this.label,
          (oldValue, newValue) => console.log({ oldValue, newValue }),
        ),
      );
    }

    // Here is how a fixed version looks like:
    componentWillLoad(): void {
      // All controllers are loaded before componentWillLoad() lifecycle
      // callback on the component is called, so you can use reactiveUtils here
      // without worrying about awaiting them.
      this.manager.onLifecycle(() =>
        this.reactiveUtils.watch(
          // controllerManager adds reactiveUtils integration to all Props and
          // States on your component:
          () => this.label,
          (newValue, oldValue) => console.log({ oldValue, newValue }),
        ),
      );
    }
    // In the above, we used an onLifecycle() helper.
    // When you provide a function to onLifecycle(), it will:
    // - call the provided callback on each connectedCallback
    //   - if component is already connected when you call onLifecycle (like in
    //     the example above, since componentWillLoad is called after
    //     connectedCallback), then the callback will be called right away
    //     the first time
    // - if your callback returned a function, or an object with a "remove"
    //   method, that function will be called on the next disconnectedCallback
    //   - in the above, the IHandle returned by watch() will be used to remove
    //     the watcher on disconnected callback
    //
    // onLifecycle is very convenient for writing your web component in a way
    // that handles connect/disconnect appropriately, and avoids memory leaks/bugs
    //
    // This is a bit like useEffect(callback, []) in React
  }

  return ExampleComponent5;
});

example("6. A controller that expects certain properties to be on the component âœ…", () => {
  // The cool part about controllers is how they allow to decouple your logic
  // into a separate function and reuse that function between your components,
  // cutting down on boilerplate a lot.

  // Let's revisit the previous example (Example 5) to see how we could extract
  // the property watcher into a separate controller.

  // In this case, the controller would need to access the "reactiveUtils" and
  // the "label" property from the component. While you could pass them as
  // arguments, doing so would add boilerplate to every place where you use this
  // controller.

  // Instead, we can declare a controller that expects certain properties to be
  // present on the component. That way, TypeScript will enforce that the
  // component has the needed properties, and you get great type checking inside
  // the component.

  // If your controller expects certain properties/methods to be present on the
  // component, you should use makeGenericController() instead of makeController()
  // and provide generic type parameters.

  // The first generic parameter is what the controller returns
  // (in this case, nothing as we don't have a "return something;" at the end,
  // so we use "void")
  // The second generic parameter is what the controller expects to be present on
  // the component
  // (in this case, reactiveUtils and a label property)
  const useReactiveController = makeGenericController<void, { reactiveUtils: __esri.reactiveUtils; label: string }>(
    async (component, controller) => {
      // Note, while componentWillLoad on the component is called after all
      // controllers are loaded, that is not the case for makeController() function
      // or Controller classes. When defining a controller, you must explicitly
      // await load for any controller you are using:
      await controller.use(component.reactiveUtils);
      // As a reminder: awaiting a controller is not necessary in
      // componentWillLoad(), or inside of the render() method as controllers
      // are guaranteed to be loaded by then.

      controller.onLifecycle(() =>
        // reactiveUtils.watch returns { remove: ()=>void }.
        // onLifecycle will automatically call that remove function on
        // disconnectedCallback()
        component.reactiveUtils.watch(
          () => component.label,
          (oldValue, newValue) => console.log({ oldValue, newValue }),
        ),
      );
    },
  );

  // We could also decouple the controller from the component a bit more by
  // loading reactiveUtils independently rather than accessing it from the
  // component (don't worry - this won't create a duplicate network request):
  const useDecoupledReactiveController = makeGenericController<void, { label: string }>(
    async (component, controller) => {
      const reactiveUtils = await importCoreReactiveUtils();
      controller.onLifecycle(() =>
        reactiveUtils.watch(
          () => component.label,
          (oldValue, newValue) => console.log({ oldValue, newValue }),
        ),
      );
    },
  );

  // and later usage:
  class ExampleComponent6 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;
    reactiveUtils = load(importCoreReactiveUtils);

    // If component was declared using makeGenericController, then "this" must be
    // passed in when initializing the controller. This is required for proper
    // type checking
    watcher = useReactiveController(this);
    watcher2 = useDecoupledReactiveController(this);

    // If "label" property is missing, useReactiveController will show a
    // TypeScript error.
    // You can open this file in your editor and give it a try - comment out
    // this property, and see an error:
    // "Property 'label' is missing in type 'ExampleComponent6'"
    @Prop() label = "a";
    // You will also see the error if your property has incorrect type:
    // "Types of property 'label' are incompatible. Type 'boolean' is not
    // assignable to type 'string'."
  }
  // You might have noticed that the type error is emitted on the line where you
  // call useReactiveController, rather than on the line where the problematic
  // property is defined. While you still get type safety, the developer
  // experience is not ideal if your controller expects many properties.
  //
  // For that reason, completely optionally, you could add
  // "implements Use<typeof yourController>" to your class declaration:
  class ExampleComponent6a implements Use<typeof useReactiveController> {
    // If you component implements any Use<...>, you no longer need to have
    // "implements BaseComponent", as that's included in Use<...> automatically

    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;
    reactiveUtils = load(importCoreReactiveUtils);

    example = useReactiveController(this);

    // Now, if the type of this prop is incorrect, you will get an inline error:
    @Prop() label = "";
    // Similarly, if you comment out this property, your IDE might suggest an
    // "implement missing properties" fix that automatically adds the needed
    // properties - isn't that cool?
  }
  // As you can see, Use<...> is not required, and if you forgot it, a type-error
  // won't slip in unnoticed, but it's a nice-to-have.

  // You can see how controllers can be used to extract business logic and
  // boilerplate like prop watchers/lifecycle hooks into a separate function.
  // Then a controller could be reused in many components.
  // This also makes testing easier as controller could be tested independently
  // from it's component (See ./5.testing.md for more on testing controllers)

  // Side Note:
  // if your controller expects arguments:
  const useName = (name: string): ((component: BaseComponent) => string) => makeGenericController((_) => name);
  // Then, for Use<...> to work, you have to provide the arguments to the
  // controller outside the class:
  const useNameInstance = useName("test");
  class ExampleComponent6b implements Use<typeof useNameInstance> {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    example = useNameInstance(this);
    @Prop() name = "";
  }
  // If this does not work for you because your controller arguments are dynamic,
  // as an alternative to Use<...>, your controller could define a type/interface
  // that extends BaseComponent, and then you could similarly use that interface
  // in your component's class declaration.

  // Side note:
  // You might have noticed that in all previous examples, rather than calling
  // makeController() function in the global scope, we wrapped it in an arrow
  // function, like so:
  // const myController = ():void => makeController(()=> ... );
  // then inside the component:
  //   controller = myController();
  //
  // This is necessary since we don't want to initialize the controller outside a
  // component (if you try that, it will complain about not being able to find
  // the component).
  //
  // This is not an issue for controllers created using makeGenericController(),
  // because makeGenericController() automatically wraps your controller in a function
  // that takes in the component as an argument (see how we called it with "this"
  // in the above examples).
  //
  // While we could wrap all controllers like that, explicitly passing "this"
  // makes using controllers a bit more verbose (especially if your controller
  // expects arguments), so in a name of developer experience, that is avoided
  // where possible.

  // And while we are on a subject of type-checking, if your controller receives
  // arguments, then make sure to specify the return type of your controller:
  // const a = (name: string): ReturnTypeHere => makeController(()=> ... );
  // This is needed for optimal type-inference (otherwise TypeScript might get
  // confused and infer things as "unknown"). If you forget to provide a return
  // type, you should see an ESLint warning (assuming you are using
  // @arcgis/eslint-config, which you should)
  //
  // Similarly, if you are using makeGenericController(), make sure to provide both
  // generic arguments, as otherwise TypeScript won't know what props your
  // controller expects to be present on the component.

  return [ExampleComponent6, ExampleComponent6a, ExampleComponent6b];
});

example("7. A controller that uses controllers inside of it âœ…", () => {
  // This contrived example has a parent controller that calls a child controller
  // twice with different arguments. The child controller might set it's own
  // lifecycle listeners or call other controllers too
  const useParent = (): string =>
    makeController(async (_component, controller) => {
      // These are two independent instances of the same controller:
      const result1 = await controller.use(useChild("Test1"));
      const result2 = await controller.use(useChild("Test2"));
      return `${result1} ${result2}`;
    });

  const useChild = (name: string): string =>
    makeController((_component, controller) => {
      controller.onLoaded(() => console.log(name));
      return name.toUpperCase();
    });

  // and later usage:
  class ExampleComponent7 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // In the console you would see this during the componentDidLoad lifecycle event:
    // 'Test1'
    // 'Test2'
    nested = useParent();

    render(): string {
      // Will be 'TEST1 TEST2';
      return this.nested;
    }
  }

  // Because TypeScript does not have a good way to express how a property's
  // type changes during component's lifecycle, controllers are typed as if they
  // are resolved right away, never loading - this greatly simplifies the usage,
  // at a cost of some type safety.
  // A controller might be used before it's fully loaded in the following places:
  // - in a default value for some property
  // - in a connectedCallback (on first connect)
  // - from inside of another controller
  // All other places (which includes render(), all other lifecycle methods and
  // your event listeners), can assume controllers are already loaded.
  //
  // To help detect incorrect usages, a loading controller is not a regular
  // object, but a proxy that throws an error if you try to access any property
  // on it before it's loaded.
  //
  // If you need to expose some limited functionality on your controller before
  // it's fully loaded (for example, to let it be used in default values for your
  // properties), see Example 10 in class-based controllers (./2.class-based.tsx)
  // for an example of that
  console.log(ex10);

  return ExampleComponent7;
});

example("8. A controller that expects another controller to be present on the component", () => {
  type HiController = {
    greet: () => void;
  };
  const useHi = (): HiController =>
    makeController(() => ({
      greet: (): void => console.log("Hi! ðŸ‘‹"),
    }));

  const useNested = makeGenericController<
    // Not returning anything
    void,
    // Expecting the other controller to be present on the component
    {
      // The "someControllerUsage" here must match the property name in your
      // component, not the controller's name. That is why, it's recommended to
      // be consistent with naming of your properties if they are to be used by
      // other controllers
      someControllerUsage: HiController;
    }
  >(async (component, controller) => {
    // Ensure other controller is loaded before we try to use it
    await controller.use(component.someControllerUsage);

    // Will print "Hi! ðŸ‘‹" to the console:
    component.someControllerUsage.greet();
  });

  // and later usage:
  class ExampleComponent8 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    someControllerUsage = useHi();
    expectantController = useNested(this);
  }
  // Note that in this case we had to call controller.use before we could use the
  // controller. If you forget to do this, no worries, you will get a helpful
  // error message:
  // Trying to access "greet" on the controller before it's loaded. Check if you
  // forgot to call `await controller.use(someController)`, or if controller threw an
  // exception
  //
  // Explicitly awaiting controller.use is necessary for two reasons:
  // - It clearly defines the order in which controllers should be loaded
  //   (makes sure child controller is loaded before parent controller)
  // - It lets you return promises in your controller, and have them resolved
  //   seamlessly by the time you need them in render() or in another controller

  return ExampleComponent8;
});

example("9. Dynamically updating component's return", () => {
  // A counter component that increments by 1 every second:
  const useCounter = (time: number): number =>
    makeController((_component, controller) => {
      let count = 0;

      const startTimer = (): ReturnType<typeof setInterval> =>
        setInterval(() => {
          count += 1;
          // Every time we set exports, the component will re-render automatically
          controller.exports = count;
        }, time);
      let interval: ReturnType<typeof setInterval> | undefined = undefined;

      // Remember to cleanup side-effect-ful logic:
      controller.onDisconnected(() => clearInterval(interval));
      // Remember that controllers are called from inside the component's
      // constructor. The component might or might not be already connected to
      // the DOM by this point (but Stencil will fire connectedCallback at least
      // once anyway).
      controller.onConnected(() => {
        clearInterval(interval);
        interval = startTimer();
      });
      // If you find the above logic bug-prone and complicated, no worries. Stay
      // put, and we will see how it can be simplifies
      // (spoiler alert: it will involve onLifecycle)

      return count;
    });

  // and later usage:
  const oneSecond = 1000;
  class ExampleComponent9 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    // No need for @State() here! Component will re-render automatically when
    // controller updates it's exports
    ticks = useCounter(oneSecond);
    // Though, if you want to use @Watch() on this property, you would still need
    // to add @State().
    // Also, if you need this to be a Prop, you can still add @Prop() decorator.

    render(): number {
      return this.ticks;
    }

    onClick(): void {
      // If necessary, component can reassign the value to which controller
      // was assigned - this won't interfere with the controller or it's
      // lifecycle hooks.
      // Except, if controller updates it's exports again, the change component
      // made would get overwritten.
      this.ticks = Math.random();
      // Controller is not notified explicitly that it's exports on the
      // component where overwritten. If you wish controller to be aware, you
      // should export an appropriate method on your controller

      // Thus, this is mostly useful when you use the controller to compute a
      // default value, and later the component alone takes care of updating that
      // value
    }

    counterConsumer = useCounterConsumer;
    syncCounterConsumer = useUnsafeSyncCounterConsumer;
  }

  // The counter controller could be more conveniently written using "onLifecycle"
  // hook instead of connected/disconnected:
  const useAltCounter = (time: number): number =>
    makeController((_component, controller) => {
      let count = 0;

      // This function is called right away the first time, and on future
      // connectedCallback:
      controller.onLifecycle(() => {
        const interval = setInterval(() => {
          count += 1;
          controller.exports = count;
        }, time);

        // This is called on disconnectedCallback:
        return () => clearInterval(interval);
      });

      return count;
    });

  // Now, let's see how to use the above controller from inside another:
  const useCounterConsumer = makeGenericController(async (_component, controller) => {
    // controller.use is a flexible utility for making sure a controller is loaded
    // before it's used.
    // You can call controller.use from anywhere - inside a promise or a callback
    // (if you wish to create a controller asynchronously)
    let count = await controller.use(useAltCounter(oneSecond), (newCount) => {
      count = newCount;
      console.log(count);
    });
    console.log(count); // 0

    // controller.use takes an optional 2nd argument - it's a callback that would
    // be called when the controller updates it's exports.

    // Alternatively, you can call useRef to get the controller instance itself,
    // rather than just it's exports:
    const counter = await controller.useRef(useAltCounter(oneSecond));
    // And the value is accessible using counter.exports property
    console.log(counter.exports); // 0
    // When component updates it's exports, the counter.exports will
    // get updated automatically (just like useRef in React), though, unlike in
    // React, the controller's code would not be re-run automatically on state
    // change (this is more akin Vue's Composables)
    // Controller instance has useful methods, like .watchExports(), as well
    // as any other methods you might have added to your controller (if you
    // defined the controller using the class syntax) - see ./2.class-based.tsx
    // for class-based controllers.

    // Note, if you destructure this object, the variable value won't be updated
    // on controller updates anymore:
    const { exports: thisValueWontBeUpdatedAnymore } = counter;

    return {
      log(): void {
        // This will always log the freshest counter value:
        console.log(counter.exports);
        // This is always 0, because it's value was destructured earlier:
        console.log(thisValueWontBeUpdatedAnymore); // 0
      },
    };
  });

  const useUnsafeSyncCounterConsumer = makeGenericController(() => {
    // If you are sure the controller you are trying to use is not async (does
    // not return a promise), and you are creating it synchronously (not inside
    // of await/not in a callback), and you don't care about watching the
    // exports (only care about the initial value), then you can call the
    // controller directly, without controller.use:
    const syncCount = useAltCounter(oneSecond);
    console.log(syncCount); // 0
    // Unlike controller.use, this does not await the controller load for async
    // controllers. Also, if the above pattern is used from inside a callback or
    // async code, the current component reference won't be passed implicitly.
    // Thus, use this pattern with caution and prefer controller.use when possible.
  });

  // If you do not wish to trigger a re-render when your component's return
  // changes, then your component can export an object, and mutate that
  // object on controller updates, rather than re-assigning the exports.

  return ExampleComponent9;
});

example("10. TypeScript generics", () => {
  // Controllers are very type-safe and friendly with TypeScript generics
  const useGeneric = <T,>(value: T): T[] =>
    makeController(() =>
      // Just an example:
      [value, value, value],
    );
  type ComplexObject = { someComplexObject: string };
  class ExampleComponent10 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    array = useGeneric<ComplexObject>({ someComplexObject: "a" });
    // Often works even if you don't explicitly specify the generic type. though
    // results are not always as good:
    array2 = useGeneric({ someComplexObject: "a" });
    onClick(): void {
      // Hover you cursor over these properties and see their types:

      console.log(this.array); // ComplexValue[]
      console.log(this.array2); // { someComplexObject: string; }[]
    }
  }

  return ExampleComponent10;
});

const ex11 = example("11. destroy() lifecycle", () => {
  const useDestroy = (): void =>
    makeController((_component, controller) => {
      console.log("Initialize something just once here");
      controller.onDestroy(() => console.log("Finally, destroy something here"));
    });
  class ExampleComponent11 implements BaseComponent {
    manager: ControllerManager<this> = useControllerManager(this);
    @Element() el!: HTMLDivElement;

    stateful = useDestroy();

    // Component must implement the following for destroy() lifecycle to be
    // available. It serves both as explicit opt-in, and as a documentation for
    // the user of your component:
    /**
     * If true, the component will not be destroyed automatically when it is
     * disconnected from the document. This is useful when you want to move the
     * component to a different place on the page, or temporary hide it. If this
     * is set, make sure to call the \`destroy\` method when you are done to prevent
     * memory leaks.
     */
    @Prop() autoDestroyDisabled = false;

    /** Permanently destroy the component */
    @Method()
    async destroy(): Promise<void> {
      await this.manager.destroy();
    }
  }

  // After component is destroyed, trying to connect it again will throw an
  // error, advising users to use autoDestroyDisabled prop if they need
  // re-connection.
  //
  // However, when possible, prefer writing code logic in way that does not require
  // a destroy() lifecycle event (use disconnect and connect instead). Reasons:
  // - destroy() is unlike common web-components patterns, and may be unexpected
  //   to your users
  // - when some components have destroy() and others don't, it's inconsistent and
  //   confusing to your users
  // - Option into destroy() requires adding boilerplate to your component
  // - if you need to add destroy() to existing component, you either need to do
  //   a breaking change, or set default value for autoDestroyDisabled to true,
  //   but that would be inconsistent with how other components do it, and also
  //   could lead to memory leaks
  //
  // destroy() exists primarily to ease the migration from JS API's widgets,
  // where destroy() is a common pattern.

  return ExampleComponent11;
});

/*** The end ***/

// Next, take a look at more-powerful class-based controllers in ./2.class-based.tsx

// Have feedback, questions or need help?
// Make a post in this GitHub Discussion:
// https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/711

/* eslint-enable @typescript-eslint/no-confusing-void-expression */

/*
 * A small helper purely to visually separate the examples.
 *
 * The callback provided to this function may return something purely to silence
 * the "is declared but not used" IDE's warning
 */
export function example<T = void>(name: string, callback: () => T): T {
  console.log(name);
  return callback();
}
